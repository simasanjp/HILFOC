<!-- Based on verilog file from: 190308_0616 -->
<!-- SVN Revision: $Rev: 1158 $        release-1.4.0.1              -->
<HTML>
<HEAD>
 <TITLE>Register Definition</TITLE>
</HEAD>
<BODY BGCOLOR="#f5fffa" LINK="black" VLINK="black">
 <h1>Register Definition</h1>
 <hr width="100%" size="1">
 <h2>Base Address Areas</h2>
 <table border cellpadding=2>
  <tr>
   <th bgcolor="#fafad2">Name</th>
   <th bgcolor="#fafad2">Base Address</th>
   <th bgcolor="#fafad2" width="20">31</th>
   <th bgcolor="#fafad2" width="20">30</th>
   <th bgcolor="#fafad2" width="20">29</th>
   <th bgcolor="#fafad2" width="20">28</th>
   <th bgcolor="#fafad2" width="20">27</th>
   <th bgcolor="#fafad2" width="20">26</th>
   <th bgcolor="#fafad2" width="20">25</th>
   <th bgcolor="#fafad2" width="20">24</th>
   <th bgcolor="#fafad2" width="20">23</th>
   <th bgcolor="#fafad2" width="20">22</th>
   <th bgcolor="#fafad2" width="20">21</th>
   <th bgcolor="#fafad2" width="20">20</th>
   <th bgcolor="#fafad2" width="20">19</th>
   <th bgcolor="#fafad2" width="20">18</th>
   <th bgcolor="#fafad2" width="20">17</th>
   <th bgcolor="#fafad2" width="20">16</th>
   <th bgcolor="#fafad2" width="20">15</th>
   <th bgcolor="#fafad2" width="20">14</th>
   <th bgcolor="#fafad2" width="20">13</th>
   <th bgcolor="#fafad2" width="20">12</th>
   <th bgcolor="#fafad2" width="20">11</th>
   <th bgcolor="#fafad2" width="20">10</th>
   <th bgcolor="#fafad2" width="20">9</th>
   <th bgcolor="#fafad2" width="20">8</th>
   <th bgcolor="#fafad2" width="20">7</th>
   <th bgcolor="#fafad2" width="20">6</th>
   <th bgcolor="#fafad2" width="20">5</th>
   <th bgcolor="#fafad2" width="20">4</th>
   <th bgcolor="#fafad2" width="20">3</th>
   <th bgcolor="#fafad2" width="20">2</th>
   <th bgcolor="#fafad2" width="20">1</th>
   <th bgcolor="#fafad2" width="20">0</th>
  </tr>
  <tr>
   <td align=left><a href="#dpm0_com"><font size="+1">dpm0_com</font></a></td>
   <td align=right>0xff001900</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
  </tr>
  <tr>
   <td align=left><a href="#dpm1_com"><font size="+1">dpm1_com</font></a></td>
   <td align=right>0xff001a00</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#c0c0c0">1</td>
   <td align=center bgcolor="#d3d3d3">0</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
   <td align=center bgcolor="#808080">.</td>
  </tr>
 </table>
 <a name="dpm0_com"></a>
 <a name="dpm1_com"></a>
 <hr width="100%" size="1">
 <h2> Base Address Area: dpm0_com, dpm1_com </h2>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=4><b>Address mapping</b></td>
  </tr>
  <tr>
   <th bgcolor="#e0ffff" align=center>DWord Offset (hex)</th>
   <th bgcolor="#e0ffff" align=center>Byte Offset (hex)</th>
   <th bgcolor="#e0ffff" align=center>Mode</th>
   <th bgcolor="#e0ffff" align=left>Register</th>
  </tr>
  <tr>
   <td align=left>0</td>
   <td align=left>0</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_cfg0x0">dpm_cfg0x0</a></td>
  </tr>
  <tr>
   <td align=left>1</td>
   <td align=left>4</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_if_cfg">dpm_if_cfg</a></td>
  </tr>
  <tr>
   <td align=left>2</td>
   <td align=left>8</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_pio_cfg0">dpm_pio_cfg0</a></td>
  </tr>
  <tr>
   <td align=left>3</td>
   <td align=left>c</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_pio_cfg1">dpm_pio_cfg1</a></td>
  </tr>
  <tr>
   <td align=left>4</td>
   <td align=left>10</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_addr_cfg">dpm_addr_cfg</a></td>
  </tr>
  <tr>
   <td align=left>5</td>
   <td align=left>14</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_timing_cfg">dpm_timing_cfg</a></td>
  </tr>
  <tr>
   <td align=left>6</td>
   <td align=left>18</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_rdy_cfg">dpm_rdy_cfg</a></td>
  </tr>
  <tr>
   <td align=left>7</td>
   <td align=left>1c</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_status">dpm_status</a></td>
  </tr>
  <tr>
   <td align=left>8</td>
   <td align=left>20</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_status_err_reset">dpm_status_err_reset</a></td>
  </tr>
  <tr>
   <td align=left>9</td>
   <td align=left>24</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_status_err_addr">dpm_status_err_addr</a></td>
  </tr>
  <tr>
   <td align=left>a</td>
   <td align=left>28</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_misc_cfg">dpm_misc_cfg</a></td>
  </tr>
  <tr>
   <td align=left>b</td>
   <td align=left>2c</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_io_cfg_misc">dpm_io_cfg_misc</a></td>
  </tr>
  <tr>
   <td align=left bgcolor="#808080">c-d</td>
   <td align=left bgcolor="#808080">30-34</td>
   <td align=left bgcolor="#808080">-</td>
   <td align=left bgcolor="#808080">&nbsp;reserved</td>
  </tr>
  <tr>
   <td align=left>e</td>
   <td align=left>38</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_tunnel_cfg">dpm_tunnel_cfg</a></td>
  </tr>
  <tr>
   <td align=left>f</td>
   <td align=left>3c</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_itbaddr">dpm_itbaddr</a></td>
  </tr>
  <tr>
   <td align=left>10</td>
   <td align=left>40</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_win1_end">dpm_win1_end</a></td>
  </tr>
  <tr>
   <td align=left>11</td>
   <td align=left>44</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_win1_map">dpm_win1_map</a></td>
  </tr>
  <tr>
   <td align=left>12</td>
   <td align=left>48</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_win2_end">dpm_win2_end</a></td>
  </tr>
  <tr>
   <td align=left>13</td>
   <td align=left>4c</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_win2_map">dpm_win2_map</a></td>
  </tr>
  <tr>
   <td align=left>14</td>
   <td align=left>50</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_win3_end">dpm_win3_end</a></td>
  </tr>
  <tr>
   <td align=left>15</td>
   <td align=left>54</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_win3_map">dpm_win3_map</a></td>
  </tr>
  <tr>
   <td align=left>16</td>
   <td align=left>58</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_win4_end">dpm_win4_end</a></td>
  </tr>
  <tr>
   <td align=left>17</td>
   <td align=left>5c</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_win4_map">dpm_win4_map</a></td>
  </tr>
  <tr>
   <td align=left bgcolor="#808080">18-1f</td>
   <td align=left bgcolor="#808080">60-7c</td>
   <td align=left bgcolor="#808080">-</td>
   <td align=left bgcolor="#808080">&nbsp;reserved</td>
  </tr>
  <tr>
   <td align=left>20</td>
   <td align=left>80</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_irq_raw0">dpm_irq_raw0</a></td>
  </tr>
  <tr>
   <td align=left>21</td>
   <td align=left>84</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_irq_raw1">dpm_irq_raw1</a></td>
  </tr>
  <tr>
   <td align=left>22</td>
   <td align=left>88</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_sirq_mask_set0">dpm_irq_host_sirq_mask_set0</a></td>
  </tr>
  <tr>
   <td align=left>23</td>
   <td align=left>8c</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_sirq_mask_set1">dpm_irq_host_sirq_mask_set1</a></td>
  </tr>
  <tr>
   <td align=left>24</td>
   <td align=left>90</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_sirq_mask_reset0">dpm_irq_host_sirq_mask_reset0</a></td>
  </tr>
  <tr>
   <td align=left>25</td>
   <td align=left>94</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_sirq_mask_reset1">dpm_irq_host_sirq_mask_reset1</a></td>
  </tr>
  <tr>
   <td align=left>26</td>
   <td align=left>98</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_sirq_masked0">dpm_irq_host_sirq_masked0</a></td>
  </tr>
  <tr>
   <td align=left>27</td>
   <td align=left>9c</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_sirq_masked1">dpm_irq_host_sirq_masked1</a></td>
  </tr>
  <tr>
   <td align=left>28</td>
   <td align=left>a0</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_dirq_mask_set0">dpm_irq_host_dirq_mask_set0</a></td>
  </tr>
  <tr>
   <td align=left>29</td>
   <td align=left>a4</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_dirq_mask_set1">dpm_irq_host_dirq_mask_set1</a></td>
  </tr>
  <tr>
   <td align=left>2a</td>
   <td align=left>a8</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_dirq_mask_reset0">dpm_irq_host_dirq_mask_reset0</a></td>
  </tr>
  <tr>
   <td align=left>2b</td>
   <td align=left>ac</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_dirq_mask_reset1">dpm_irq_host_dirq_mask_reset1</a></td>
  </tr>
  <tr>
   <td align=left>2c</td>
   <td align=left>b0</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_dirq_masked0">dpm_irq_host_dirq_masked0</a></td>
  </tr>
  <tr>
   <td align=left>2d</td>
   <td align=left>b4</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_irq_host_dirq_masked1">dpm_irq_host_dirq_masked1</a></td>
  </tr>
  <tr>
   <td align=left>2e</td>
   <td align=left>b8</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_sw_irq">dpm_sw_irq</a></td>
  </tr>
  <tr>
   <td align=left>2f</td>
   <td align=left>bc</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_crc">dpm_crc</a></td>
  </tr>
  <tr>
   <td align=left>30</td>
   <td align=left>c0</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_reserved_netx50_wgd_host_timeout">dpm_reserved_netx50_wgd_host_timeout</a></td>
  </tr>
  <tr>
   <td align=left>31</td>
   <td align=left>c4</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_reserved_netx50_wgd_host_trigger">dpm_reserved_netx50_wgd_host_trigger</a></td>
  </tr>
  <tr>
   <td align=left>32</td>
   <td align=left>c8</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_reserved_netx50_wgd_netx_timeout">dpm_reserved_netx50_wgd_netx_timeout</a></td>
  </tr>
  <tr>
   <td align=left>33</td>
   <td align=left>cc</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_sys_sta_bigend16">dpm_sys_sta_bigend16</a></td>
  </tr>
  <tr>
   <td align=left>34</td>
   <td align=left>d0</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_reserved_netx50_timer_ctrl">dpm_reserved_netx50_timer_ctrl</a></td>
  </tr>
  <tr>
   <td align=left>35</td>
   <td align=left>d4</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_reserved_netx50_timer_start_val">dpm_reserved_netx50_timer_start_val</a></td>
  </tr>
  <tr>
   <td align=left>36</td>
   <td align=left>d8</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_sys_sta">dpm_sys_sta</a></td>
  </tr>
  <tr>
   <td align=left>37</td>
   <td align=left>dc</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_reset_request">dpm_reset_request</a></td>
  </tr>
  <tr>
   <td align=left>38</td>
   <td align=left>e0</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_firmware_irq_raw">dpm_firmware_irq_raw</a></td>
  </tr>
  <tr>
   <td align=left bgcolor="#808080">39-3b</td>
   <td align=left bgcolor="#808080">e4-ec</td>
   <td align=left bgcolor="#808080">-</td>
   <td align=left bgcolor="#808080">&nbsp;reserved</td>
  </tr>
  <tr>
   <td align=left>3c</td>
   <td align=left>f0</td>
   <td align=left>R/W</td>
   <td align=left><a href="#dpm0_com_dpm_firmware_irq_mask">dpm_firmware_irq_mask</a></td>
  </tr>
  <tr>
   <td align=left>3d</td>
   <td align=left>f4</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_netx_version_bigend16">dpm_netx_version_bigend16</a></td>
  </tr>
  <tr>
   <td align=left bgcolor="#808080">3e</td>
   <td align=left bgcolor="#808080">f8</td>
   <td align=left bgcolor="#808080">-</td>
   <td align=left bgcolor="#808080">&nbsp;reserved</td>
  </tr>
  <tr>
   <td align=left>3f</td>
   <td align=left>fc</td>
   <td align=left>R</td>
   <td align=left><a href="#dpm0_com_dpm_netx_version">dpm_netx_version</a></td>
  </tr>
 </table><br>
 <a name="dpm0_com_dpm_cfg0x0"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_cfg0x0</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM IO Control Register 0.<br>This register is accessible in any DPM-mode (8, 16 bit, SRAM, Intel, Motorola, little endian, big endian) by access to DPM address 0.<br>Basic DPM settings are configurable here to make higher addresses accessible.<br>To avoid instable system configurations, global changes of important configuration registers must be confirmed<br>(re)writing 'mode' bit field of this register. View 'mode' description for details. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001900<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a00<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;6</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>5&nbsp;-&nbsp;4</td>
   <td>&quot;00&quot;<br></td>
   <td>endian<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Endianess of 32 bit (DWord) address alignment (B0: least significant byte, B3: most significant byte): </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> coding </td>
       <td valign=top> &nbsp;&nbsp;Address </td>
       <td valign=top> &nbsp;&nbsp;A+3 </td>
       <td valign=top> &nbsp;&nbsp;A+2 </td>
       <td valign=top> &nbsp;&nbsp;A+1 </td>
       <td valign=top> &nbsp;&nbsp;A+0 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;00 </td>
       <td valign=top> &nbsp;&nbsp;little endian </td>
       <td valign=top> &nbsp;&nbsp;B3 </td>
       <td valign=top> &nbsp;&nbsp;B2 </td>
       <td valign=top> &nbsp;&nbsp;B1 </td>
       <td valign=top> &nbsp;&nbsp;B0 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;01 </td>
       <td valign=top> &nbsp;&nbsp;16 bit big endian </td>
       <td valign=top> &nbsp;&nbsp;B2 </td>
       <td valign=top> &nbsp;&nbsp;B3 </td>
       <td valign=top> &nbsp;&nbsp;B0 </td>
       <td valign=top> &nbsp;&nbsp;B1 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;10 </td>
       <td valign=top> &nbsp;&nbsp;32 bit big endian </td>
       <td valign=top> &nbsp;&nbsp;B0 </td>
       <td valign=top> &nbsp;&nbsp;B1 </td>
       <td valign=top> &nbsp;&nbsp;B2 </td>
       <td valign=top> &nbsp;&nbsp;B3 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;11 </td>
       <td valign=top> &nbsp;&nbsp;reserved </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp; </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Little endian is used netX inside. If big endian host device is used, set to this 01 or 10 according to<br>host device data width. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3&nbsp;-&nbsp;0</td>
   <td>&quot;0000&quot;<br></td>
   <td>mode<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Basic DPM interface mode:<br>Additionally writing to this bit field will confirm global interface configuration changes:<br>Interface configuration can not always be written one single access (e.g. in 8 bit data mode<br>changing of 'dpm_if_cfg' is not possible in one single access as there are more than 8 bits<br>for configuration). However changing interface configuration by more than one single access could<br>lead to instable interfaces. This is avoided by following procedure:<br>For proper interface configuration, values of important interface configuration<br>registers are buffered in temporary registers first. Interface configuration is changed<br>finally by (re)writing 'mode' bits. There is no need to really change a prior programmed 'mode'<br>setting, interface change is done when low byte of this registers is target of a write access.<br>Temporary registers which must be confirmed by this are:<br>- All bits of 'dpm_if_cfg' register.<br>Note:<br>&nbsp;&nbsp;The address comparators and the 'addr_cmp_a*' bit fields in 'dpm_addr_cfg' of earlier netX versions<br>&nbsp;&nbsp;were dropped since netX90.<br>Note:<br>&nbsp;&nbsp;&nbsp;Interface configuration confirm must be done regardless wether programmed by host via<br>&nbsp;&nbsp;&nbsp;external interfaces or by internal ARM via internal INTLOGIC configuration channel.<br>DPM interface mode must be further configured in 'dpm_if_cfg' register. Data width and<br>address multiplexing mode must be configure here.<br>Supported basic DPM modes are: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 0000<br> </td>
       <td valign=top> 8 bit data non multiplexed mode.<br>DPM_D7..0 are used as data lines, DPM_D15..8 can be used as PIOs (+8 PIOs).<br>DPM_A16 can be used as Address-Enable DPM_AEN/DPM_ALE. </td>
      </tr>
      <tr>
       <td valign=top> 0001 </td>
       <td valign=top> reserved. </td>
      </tr>
      <tr>
       <td valign=top> 0010<br><br><br><br><br> </td>
       <td valign=top> 8 bit data multiplexed mode.<br>DPM_D7..0 are used as address and data lines, DPM_A16 as ALE.<br>DPM_A7..0 and DPM_D15..8 can be used as PIOs (+16 PIOs).<br>DPM_A10..8 will used as address lines.<br>DPM_A17, DPM_A15..11 can used as address lines (depending on selected 'addr_range'.<br>High address lines will be sampled at the same time when lower address bits are<br>latched from DPM_D7..0. </td>
      </tr>
      <tr>
       <td valign=top> 0011 </td>
       <td valign=top> reserved. </td>
      </tr>
      <tr>
       <td valign=top> 0100<br> </td>
       <td valign=top> 16 bit data non multiplexed mode.<br>DPM_D15..0 are used as data lines.<br>DPM_A16 can be used as Address-Enable DPM_AEN/DPM_ALE. </td>
      </tr>
      <tr>
       <td valign=top> 0101 </td>
       <td valign=top> reserved. </td>
      </tr>
      <tr>
       <td valign=top> 0110<br><br><br><br><br> </td>
       <td valign=top> 16 bit data multiplexed mode with 2 byte-enables on separated lines.<br>DPM_D15..0 are used as address and data lines, DPM_A16 as ALE.<br>DPM_A15..0 can be used as PIOs (+16 PIOs).<br>Two byte-enable signals can be used additionally. View register 'dpm_if_cfg' 'be_sel'.<br>DPM_A17 can used as address lines (depending on selected 'addr_range'.<br>High address lines will be sampled at the same time when lower address bits are<br>latched from DPM_D15..0. </td>
      </tr>
      <tr>
       <td valign=top> 0111 </td>
       <td valign=top> reserved </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;: </td>
       <td valign=top> reserved. </td>
      </tr>
      <tr>
       <td valign=top> 1111 </td>
       <td valign=top> reserved. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;For DPM modes with less than 32 bit data, write data could not written immediate to netX memory or<br>&nbsp;&nbsp;&nbsp;registers ('byte_area' and 'dis_rd_latch' of 'dpm_win1_map' register). </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_if_cfg"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_if_cfg</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM interface configuration register.<br>DPM interface mode must be basically configured in 'dpm_cfg0x0' register. Interface configuration is<br>split up into two registers to support setup from external host CPU when DPM is in 8 bit non-multiplexed default mode after reset.<br>However this does not work for all interfaces. E.g. for modes where DPM_WRN is not write trigger this is not<br>possible. Interface setup must be done by netX internal CPU then.<br>To avoid instable system configurations, changes of this registers must be confirmed<br>(re)writing 'mode' bit field of dpm_cfg0x0 register. View 'mode' description there for details.<br> </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;Host connection </td>
       <td valign=top> &nbsp;cs_ctrl </td>
       <td valign=top> &nbsp;addr_sh </td>
       <td valign=top> &nbsp;aen_pol </td>
       <td valign=top> &nbsp;aen_sel </td>
       <td valign=top> &nbsp;be_wr </td>
       <td valign=top> &nbsp;be_rd </td>
       <td valign=top> &nbsp;be_pol </td>
       <td valign=top> &nbsp;be_sel </td>
       <td valign=top> &nbsp;dir_ctrl </td>
       <td valign=top> &nbsp;cfg_0x0.mode </td>
      </tr>
      <tr>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp;_dis </td>
       <td valign=top> &nbsp;_dis </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp; </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;SRAM or Intel 8bit </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x0 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;SRAM, 16bit,byte-enable </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x4 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;SRAM, or Intel, 8bit multiplexed </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x2 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;SRAM, 16bit mul. (netx50: Intel, no BEs) </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x6 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;SRAM, 16bit mul. 2BEs, byte-addr </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x6 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;SRAM, 16bit mul. 2BEs, word-addr </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x6 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;Intel, 16bit,byte-write </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x4 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;Intel, 16bit mul. byte-write </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x6 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;TI OMAP, 16bit non-multiplexed </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x4 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;TI OMAP, 16bit multiplexed </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x6 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;Motorola, 8bit (6800) </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x0 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;Motorola, 16bit </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x4 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;Motorola, 16bit (68000) </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x4 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;Motorola, 8bit multiplexed </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x2 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;Motorola, 16bit mul.netx50: byte-addr </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x6 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;Motorola, 16bit mul.word-addr </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;0x6 </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001904<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a04<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;19</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>18&nbsp;-&nbsp;16</td>
   <td>&quot;000&quot;<br></td>
   <td>cs_ctrl<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Chip-select controlling. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;000: </td>
       <td valign=top> Use 1 low active chip-select signal (DPM_CSN). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;001: </td>
       <td valign=top> Use 2 low active chip-select signals (DPM_CSN or DPM_BHE1n must be low). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;010: </td>
       <td valign=top> Use high active chip-select signal (DPM_CSN). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;011: </td>
       <td valign=top> Use 2 high active chip-select signals (DPM_CSN or DPM_BHE1n must be high). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;100: </td>
       <td valign=top> No chip-select signal. Behaves like DPM_CSN is permanent active. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;111: </td>
       <td valign=top> Chip access is disabled. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;others: </td>
       <td valign=top> reserved </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;The address comparators and the 'addr_cmp_a*' bit fields in 'dpm_addr_cfg' of earlier netX versions<br>&nbsp;&nbsp;were dropped since netX90. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>15</td>
   <td>&quot;0&quot;<br></td>
   <td>addr_sh<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Address is Byte address or shifted according to selected data size.<br>This bit is irrelevant in 8 bit data modes. Address comparator logic works always with unshifted<br>address. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;0<br> </td>
       <td valign=top> Address is always Byte address (not shifted).<br>In 16 bit data modes: Address bit 0 can be used as low byte-enable or can be ignored.<br>Use 'be_sel' to select byte-enables and 'be_wr_dis' or 'be_rd_dis' to ignore them. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;1 </td>
       <td valign=top> Address is shifted according to programmed data width.<br>In 16 bit data modes: Address from host starting at A0 (or AD0 when multiplexed ) is 16 bit word address. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>14</td>
   <td>&quot;0&quot;<br></td>
   <td>aen_pol<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Address-Enable active level polarity. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;0: </td>
       <td valign=top> Address is latched while ALE-signal is low (i.e. low active ALE/AEN). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;1: </td>
       <td valign=top> Address is latched while ALE-signal is high (i.e. high active ALE/AEN). </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> In non-multiplexed modes, address is only latched when chip-select is additionally active (as programmed<br>in 'cs_ctrl').<br>In multiplexed modes, address latching is not controlled by chip-select. Address is latched all time<br>when ALE is active then. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>13&nbsp;-&nbsp;12</td>
   <td>&quot;00&quot;<br></td>
   <td>aen_sel<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Address-Enable (AEN-modes) or Address-Latch-Enable (multiplexed modes) Control. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;00: </td>
       <td valign=top> No additional Address controlling function. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;01: </td>
       <td valign=top> reserved </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;10: </td>
       <td valign=top> AEN on HIF_A16 (up to 64kB address space for non-multiplexed modes). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;11: </td>
       <td valign=top> reserved. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;In multiplexed modes read or write access will not be started netX internally while address-phase<br>&nbsp;&nbsp;&nbsp;is active. ALE signal must return to idle state first. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>11&nbsp;-&nbsp;10</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>9&nbsp;-&nbsp;8</td>
   <td>&quot;00&quot;<br></td>
   <td>be_pol<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM access byte-enable active level polarity.<br>byte-enable active polarity can be set for each data byte separately. byte-enable signals<br>can be selected by 'be_sel'.<br>Bits inside this bit field are associated as follows: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;Bit </td>
       <td valign=top> data lines </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;be_pol[0] </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;D[7:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;be_pol[1] </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;D[15:8] </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Function: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;0: </td>
       <td valign=top> BE signals are low active byte-enables. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;1: </td>
       <td valign=top> BE signals are high active byte-enables (e.g. 8 bit Motorola 6800). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7</td>
   <td>&quot;0&quot;<br></td>
   <td>be_wr_dis<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM write access byte-enable configuration. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;0: </td>
       <td valign=top> byte-enables will be used on write access, only data lines of enabled bytes will be written. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;1: </td>
       <td valign=top> byte-enables will be ignored on write access, all used data lines will be written. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;Do not set this bit when 'dir_ctrl' is set to nWR-mode ('01'). Byte-Write-Strobes are essentially in this case.<br>Note:<br>&nbsp;&nbsp;&nbsp;This bit is ignored for 8 bit data modes when 'be_sel' bit is not set. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6</td>
   <td>&quot;0&quot;<br></td>
   <td>be_rd_dis<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM read access byte-enable configuration. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;0: </td>
       <td valign=top> byte-enables will be used on read access, only data lines of enabled bytes will be driven. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;1: </td>
       <td valign=top> byte-enables will be ignored on read access, all used data lines will be driven. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;Do not set this bit when 'dir_ctrl' is set to nRW-mode ('10'). Byte-Write-Strobes are essentially in this case.<br>Note:<br>&nbsp;&nbsp;&nbsp;This bit is ignored for 8 bit data modes when 'be_sel' bit is not set. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>5</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>be_sel<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM access byte-enable signal selection.<br>Basically BE signals depend on selected data width (cfg0x0). </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> setting </td>
       <td valign=top> &nbsp;data width </td>
       <td valign=top> &nbsp;D[15:8] </td>
       <td valign=top> &nbsp;D[7:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;8bit </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
       <td valign=top> &nbsp;&nbsp;16bit </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;BHE1n </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A0 </td>
      </tr>
      <tr>
       <td valign=top> --------- </td>
       <td valign=top> ------------- </td>
       <td valign=top> ---------- </td>
       <td valign=top> -------- </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;8bit </td>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp;&nbsp;BHE1n </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;16bit </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;A17 </td>
       <td valign=top> &nbsp;&nbsp;WRn </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;For 8 bit data modes this bit must only be set when an additional<br>&nbsp;&nbsp;&nbsp;byte-enable Signal is required (e.g. Motorola 6800). Do not set 'be_sel' and ignore<br>&nbsp;&nbsp;&nbsp;for read and write (be_wr_dis, be_rd_dis) - DPM Ready generation will care<br>&nbsp;&nbsp;&nbsp;for BHE1n anyhow.<br>Note:<br>&nbsp;&nbsp;&nbsp;Internal read access data width is always 32 bit. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3&nbsp;-&nbsp;2</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>1&nbsp;-&nbsp;0</td>
   <td>&quot;00&quot;<br></td>
   <td>dir_ctrl<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM access direction control. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;00:<br><br><br><br><br><br><br> </td>
       <td valign=top> dedicated low active read- and write control signals (RDn + WRn) with optional byte-enables.<br>byte-enables have address character i.e. they must be stable while read- or write-control<br>signal is active. byte-enables are not used as Strobe signals.<br>A read-access is started when RDn signal becomes active low at access start. Address, chip-select and<br>byte-enable signals must be stable then.<br>A write-access is done when WRn becomes inactive high at access end. Address, chip-select, data and<br>byte-enable signals must be stable then.<br>Ready/Busy signal is asserted when RDn or WRn is active.<br>This setting can be used for standard SRAM interfaces. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;01:<br><br><br><br><br><br><br><br> </td>
       <td valign=top> RDn is direction signal nRW (signal high: write, low: read).<br>For read byte-enables have address character i.e. they must be stable when RDn becomes low.<br>For write byte-enables have strobe character i.e. Address, Data and RDn must be stable when they<br>become inactive at access end..<br>A read-access is started when RDn signal becomes low at access start. Address, chip-select and<br>byte-enable signals must be stable then.<br>A write-access is done when byte-enables becomes inactive at access end. Address, chip-select, data and<br>RDn signals must be stable then.<br>Ready/Busy signal is asserted when RDn is low or byte-enables are active.<br>This setting is typically used for Intel-like interfaces with Byte-Write-Strobe signals.. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;10:<br><br><br><br> </td>
       <td valign=top> RDn is direction signal nWR (signal low: write, high: read).<br>byte-enables have strobe character for both read and write i.e. Address, and RDn must be stable when they<br>become active at access start. These signals must remain stable until byte-enables become inactive<br>at access end. For write data must be stable then.<br>Ready/Busy signal is asserted when at least one byte-enables is active.<br>This setting is typically used for Motorola-like interfaces with Byte-Write-Strobe signals. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_pio_cfg0"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_pio_cfg0</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM PIO Configuration Register0.<br>Signals to be used as PIOs when netX DPM is active must be selected here or in 'dpm_pio_cfg1' register. Since netx51/52<br>PIO function will not be automatically activated depending on other settings. E.g. DPM_D15..8 can not be used<br>automatically when 8 bit data mode is selected. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001908<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a08<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;16</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>15&nbsp;-&nbsp;0</td>
   <td>0x0<br></td>
   <td>sel_d_pio<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Use related DPM_D-pin as PIO pin. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_pio_cfg1"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_pio_cfg1</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM PIO Configuration Register1.<br>PIO usage of DPM_SIRQ, DPM_DIRQ and DPM_RDY has moved from 'dpm_io_cfg_misc' to this register since netx51/52.<br>Signals to be used as PIOs when netX DPM is active must be selected here or in 'dpm_pio_cfg0' register. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0xe0000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff00190c<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a0c<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31</td>
   <td>&quot;1&quot;<br></td>
   <td>sel_sirq_pio<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Use DPM_SIRQ-pin as PIO pin.<br>Note:<br>&nbsp;&nbsp;&nbsp;For serial DPM this bit is related to netX51/52 IO HIF_D13. Setting of for HIF_D13<br>&nbsp;&nbsp;&nbsp;inside 'dpm_pio_cfg0 register is ignored then. I.e. this bit must be programmed<br>&nbsp;&nbsp;&nbsp;to '0' for DPM_SIRQ/FIQ usage regardless whether serial or parallel DPM is used. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>30</td>
   <td>&quot;1&quot;<br></td>
   <td>sel_dirq_pio<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Use DPM_DIRQ-pin as PIO pin.<br>Note:<br>&nbsp;&nbsp;&nbsp;For serial DPM this bit is related to netX51/52 IO HIF_D12. Setting of for HIF_D12<br>&nbsp;&nbsp;&nbsp;inside 'dpm_pio_cfg0 register is ignored then. I.e. this bit must be programmed<br>&nbsp;&nbsp;&nbsp;to '0' for DPM_DIRQ/IRQ usage regardless whether serial or parallel DPM is used. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>29</td>
   <td>&quot;1&quot;<br></td>
   <td>sel_rdy_pio<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Use DPM_RDY-pin as PIO pin. RDY is by default PIO to avoid RDY-conflicts during reset. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>28</td>
   <td>&quot;0&quot;<br></td>
   <td>sel_wrn_pio<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Use DPM_WRN-pin as PIO pin. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>27</td>
   <td>&quot;0&quot;<br></td>
   <td>sel_rdn_pio<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Use DPM_RDN-pin as PIO pin. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>26</td>
   <td>&quot;0&quot;<br></td>
   <td>sel_csn_pio<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Use DPM_CSN-pin as PIO pin. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>25</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>24</td>
   <td>&quot;0&quot;<br></td>
   <td>sel_bhe1_pio<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Use DPM_BHE1-pin as PIO pin. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>23&nbsp;-&nbsp;20</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>19&nbsp;-&nbsp;0</td>
   <td>0x0<br></td>
   <td>sel_a_pio<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Use related DPM_A-pin as PIO pin.<br>Note:<br>&nbsp;&nbsp;&nbsp;PIO selects for DPM_A19..18 are only used for test purpose here. To select PIO function<br>&nbsp;&nbsp;&nbsp;of high DPM_A lines which are multiplexed on DPM_D23..22 use related bits of 'sel_d_pio'<br>&nbsp;&nbsp;&nbsp;Bit field in 'dpm_pio_cfg0' register. DPM_A17..16 are treated in the same way in netx50<br>&nbsp;&nbsp;&nbsp;compatibility mode (located on DPM_D21..20 then). However they are located on HIF_AHI1..0<br>&nbsp;&nbsp;&nbsp;when netx50 compatibility is globally disabled (ASIC_CTRL-area). </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_addr_cfg"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_addr_cfg</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM External Address Configuration Register.<br>Note:<br>&nbsp;&nbsp;&nbsp;There are no internal address comparators and no DPM_SELA* functions available for netX90. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000002<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001910<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a10<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;6</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>5&nbsp;-&nbsp;4</td>
   <td>&quot;00&quot;<br></td>
   <td>cfg_win_addr_cfg<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Location of the DPM Configuration Window (Window 0).<br>Supported settings are: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;00: </td>
       <td valign=top> Low Configuration Window: The Configuration Window is located in the first 256 bytes of external DPM address<br>range (0x0 to 0xff). It is located before the first enabled Data Window (1 to 4). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;01: </td>
       <td valign=top> High Configuration Window: The Configuration Window is located in the last 256 bytes of external DPM address<br>range. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example: 'addr_range' is 8kB: Configuration Window is located in 0x1F00..0x1FFF. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;10: </td>
       <td valign=top> reserved. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;11: </td>
       <td valign=top> Configuration Window is disabled for external DPM access. Full DPM address<br>range can be used for Windows 1 to 4. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;The Configuration Window 0 has higher priority than normal DPM Window. The location of the Configuration Window<br>&nbsp;&nbsp;does not depend on the Data Window configuration (the setting of the 'dpm_winX_end' or 'dpm_winX_map' registers).<br>&nbsp;&nbsp;I.e. for setting '00' (low Configuration Window) the first enabled Data Window starts at address 0x100. For<br>&nbsp;&nbsp;setting '01' (high Configuration Window) it would hide the last 256 bytes of the last enabled Data Window when<br>&nbsp;&nbsp;this is configured to end on the last external address.<br>&nbsp;&nbsp;The Configuration Window 0 has lower priority than Access Tunnel. I.e. the Access Tunnel could be laid over<br>&nbsp;&nbsp;the configuration window. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3&nbsp;-&nbsp;0</td>
   <td>&quot;0010&quot;<br></td>
   <td>addr_range<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM external address range. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> coding </td>
       <td valign=top> Byte Address range </td>
       <td valign=top> address used signals </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;0000 </td>
       <td valign=top> reserved </td>
       <td valign=top> &nbsp; </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;0001 </td>
       <td valign=top> reserved </td>
       <td valign=top> &nbsp; </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;0010 </td>
       <td valign=top> 2KB address range </td>
       <td valign=top> DPM_A[10:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;0011 </td>
       <td valign=top> 4KB address range </td>
       <td valign=top> DPM_A[11:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;0100 </td>
       <td valign=top> 8KB address range </td>
       <td valign=top> DPM_A[12:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;0101 </td>
       <td valign=top> 16KB address range </td>
       <td valign=top> DPM_A[13:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;0110 </td>
       <td valign=top> 32KB address range </td>
       <td valign=top> DPM_A[14:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;0111 </td>
       <td valign=top> 64KB address range </td>
       <td valign=top> DPM_A[15:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;1000 </td>
       <td valign=top> 128KB address range </td>
       <td valign=top> DPM_A[16:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;1001 </td>
       <td valign=top> 256KB address range </td>
       <td valign=top> DPM_A[17:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;: </td>
       <td valign=top> reserved </td>
       <td valign=top> &nbsp; </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;1111 </td>
       <td valign=top> reserved </td>
       <td valign=top> &nbsp; </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> <br>Following settings are only valid for 8 bit non-multiplexed data mode. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> coding </td>
       <td valign=top> Byte Address range </td>
       <td valign=top> address used signals </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;1010 </td>
       <td valign=top> 512KB address range </td>
       <td valign=top> HIF_D8, DPM_A[17:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;1011 </td>
       <td valign=top> 1024KB address range </td>
       <td valign=top> HIF_D9, HIF_D8, DPM_A[17:0] </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;: </td>
       <td valign=top> reserved </td>
       <td valign=top> &nbsp; </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;1111 </td>
       <td valign=top> reserved </td>
       <td valign=top> &nbsp; </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> <br>This setting is related to Byte address. I.e. it is not possible to expand address rage<br>by setting the 'addr_sh' bit inside the 'dpm_if_cfg' register. However required address lines<br>will decrease by 1 for 16 bit data mode when the 'addr_sh' bit is set.<br><br>For multiplexed modes:<br>If programmed address range exceeds number of data lines, high address bits will be sampled<br>from DPM_A lines starting above last used data line. High address will be sampled at the same moment<br>when low address bits are sampled from data lines.<br>Example 1:<br>8 bit data multiplexed mode, 64KB address range programmed and 'aen_pol' is set to 0:<br>Address bits A7..0 are sampled from DPM_D7..0 before DPM_ALE is released to 1. Address bits A15..8<br>are sampled from DPM_A15..8 also before DPM_ALE is released to 1.<br>Example 2:<br>16 bit data multiplexed mode, 64KB address range programmed, 'aen_pol' is set<br>to 0 and 'addr_sh' is set to 1:<br>Address bits A15..1 are sampled from DPM_D14..0 before DPM_ALE is released to 1.<br>I.e. a 16 bit word address is<br>carried on DPM_D14..0 and is left-shifted internally by 1 to resolve a byte address. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_timing_cfg"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_timing_cfg</b></font><br><font size="-2">(dpm_access_cfg)</font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM timing and access configuration register. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000027<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001914<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a14<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31</td>
   <td>&quot;0&quot;<br></td>
   <td>sdpm_miso_early<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Serial DPM early MISO (read-data) generation.<br>Serial DPM based on standard SPI changes read data on the edge following the sampling clock edge, i.e.<br>works on both serial clock edges. That avoids hold timing errors on MISO-data but decreases<br>maximum serial data rate on the other hand. Hence, for fast serial data rates this bit must be set.<br>MISO hold times will always be positive but could get very short then. For details view netX<br>timing characteristics. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;0: </td>
       <td valign=top> Change MISO on the clock edge following the sampling edge. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;1: </td>
       <td valign=top> Change MISO on the sampling edge. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;Sampling and generating clock edges are determined by serial DPM mode (clock phase and polarity).<br>&nbsp;&nbsp;&nbsp;Related configuration must be done outside DPM module.<br>Note:<br>&nbsp;&nbsp;&nbsp;Hold timings can be relaxed by decreasing serial clock rate when this bit is not set. When this<br>&nbsp;&nbsp;&nbsp;bit is set, MISO hold timing does not depend on serial clock rate.<br>Note:<br>&nbsp;&nbsp;&nbsp;This is a new netx51/52 feature. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>30</td>
   <td>&quot;0&quot;<br></td>
   <td>en_dpm_serial_sqi<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> When DPM is in serial mode ('dpm_status.sel_dpm_serial' active), serial DPM<br>can be switched to SQI-compatible 4-bit mode.<br>Note:<br>&nbsp;&nbsp;&nbsp;Netx DPM changes serial configuration immediately when this bit is changed. Hence<br>&nbsp;&nbsp;&nbsp;do not change this bit by a longer serial sequence from host.<br>&nbsp;&nbsp;&nbsp;E.g.: Change from SPI to SQI from host-side when host: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;1.: </td>
       <td valign=top> Set this bit by SPI write sequence from host. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;2.: </td>
       <td valign=top> Terminate sequence after the byte containing this bit was written. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;3.: </td>
       <td valign=top> Ensure that host has completed writing this byte serially (host transfer could last<br>even when related commands are already finished, e.g. due to FIFOs inside host SPI module). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;4.: </td>
       <td valign=top> Change host to SQI. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;5.: </td>
       <td valign=top> Continue accessing netX DPM in SQI mode. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;This bit has no effect when DPM is in parallel mode.<br>Note:<br>&nbsp;&nbsp;&nbsp;This is a new netx51/52 feature. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>29&nbsp;-&nbsp;8</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>7</td>
   <td>&quot;0&quot;<br></td>
   <td>rd_burst_en<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Read burst enable.<br>Read bursts are subsequent read accesses without toggling chip-select or read-enable in between.<br>They are supported for non-multiplexed modes only. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6&nbsp;-&nbsp;4</td>
   <td>&quot;010&quot;<br></td>
   <td>t_rds<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Read data setup time (in steps of 10ns).<br>For parallel DPM:<br>If DPM_RDY-signal is used (rdy_mode != 0), ready-state is generated t_rds*10ns after read data is stored on data bus.<br>Without using the DPM_RDY-signal (rdy_mode == 0) read access error is detected if access terminates before t_rds*10ns<br>passed after read data generation.<br>Valid settings for parallel DPM are: 0..7.<br>Note:<br>&nbsp;&nbsp;&nbsp;The read-data-access-time will increased by t_rds * 10ns if t_rds is not 0.<br>For serial DPM (since final netX90):<br>t_rds defines the guaranteed setup time of the first bit of serial read data before its sampling clock edge (MISO<br>before sampling edge of SCK). By default (t_rds=2) the first bit of serial read data may become valid on MISO<br>shortly befor the sampling edge of SCK (t_SPMOS, typically some nanoseconds, refer to the detailed IO-timing<br>description of the serial DPM). If the serial read data becomes valid later, a rd_err is detected (register dpm_status).<br>Typically t_SPMOS is sufficient. However, for serial masters requiring a longer&nbsp;&nbsp;setup time, t_rds can be used to<br>shift the access-error-detection to an earlier point of time in steps of 10ns: The rd_err-state will be detected if the serial-read-data<br>is not generated at least t_SPMOS + (t_rds-2)*10ns before the sampling clock edge. Hence t_rds does not really provide<br>a longer setup time but it allows to detect accesses with too short setup-times and provides the possibility<br>to repeat them (similar to parallel DPM without DPM_RDY-signal).<br>Valid settings for serial DPM are: 2..7. The recommended value is 2.<br>Note:<br>&nbsp;&nbsp;&nbsp;It makes no sense to set t_rds in a way that leads to a setup-time larger than the half serial period. The serial<br>&nbsp;&nbsp;&nbsp;clock rate must be reduced then additionally. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;1&quot;<br></td>
   <td>filter<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Filter DPM Control Signals.<br>If this bit is set, DPM signals chip-select, Read-Enable and Write-Enable (and Address latch enable if multiplexed<br>Parallel DPM modes are used) are filtered for spike suppression. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;0: </td>
       <td valign=top> no spike suppression. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;1: </td>
       <td valign=top> Spikes < 10ns are suppressed, read data access time increased by 10ns. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;Data, address and byte-enable inputs are not filtered and must be stable when sampled. I.e. during<br>&nbsp;&nbsp;&nbsp;the last 20ns of a write access and at the first 10ns of read access start.<br>Note:<br>&nbsp;&nbsp;&nbsp;Read data access time is increased by 10ns if this bit is set. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1&nbsp;-&nbsp;0</td>
   <td>&quot;11&quot;<br></td>
   <td>t_osa<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Address Setup Time (t_osa * 10ns).<br>Address sampling can be delayed for read and write accesses by this parameter.<br>E.g. host device asserts chip-select, Read-Enable and address lines simultaneously but<br>some address lines are not stable while chip-select and Read-Enable are both low, set t_osa<br>to delay address sampling by t_osa * 10ns.<br>When data direction is controlled by RDn line ('if_cfg.dir_ctrl' not '00') and byte-enables are used<br>for read ('if_cfg.be_rd_dis' not set), a read access is initiated when active byte-enable signals<br>are detected stable for t_osa netX clock periods.<br>Valid settings are: 0..3.<br>Note:<br>&nbsp;&nbsp;&nbsp;Read data access time will increased by t_osa * 10ns if t_osa is not 0. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_rdy_cfg"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_rdy_cfg</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Ready (DPM_RDY) Signal Configuration Register. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000001<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001918<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a18<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;6</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>5&nbsp;-&nbsp;4</td>
   <td>&quot;00&quot;<br></td>
   <td>rdy_to_cfg<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Ready Timeout Configuration.<br>Ready Timeout detection can controlled this bit. For further information<br>see description of rdy_to_err bit of dpm_status register. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 00: </td>
       <td valign=top> Ready Timeout after 2048 netX system clock cycles (i.e. 20.48us, not netx50 compatible) </td>
      </tr>
      <tr>
       <td valign=top> 01: </td>
       <td valign=top> Ready Timeout after 256 netX system clock cycles (i.e. 2.56us, netx50 compatible) </td>
      </tr>
      <tr>
       <td valign=top> 10: </td>
       <td valign=top> reserved </td>
      </tr>
      <tr>
       <td valign=top> 11: </td>
       <td valign=top> Ready Timeout disabled. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> The value programmed here is ignored for serial DPM with stream-type 'ready-polling'. In this mode<br>no ready-timeout will be generated to avoid additional status checking. A ready-polling timeout<br>counter should be implemented in serial DPM host application.<br>Note:<br>&nbsp;&nbsp;&nbsp;This is a new netx51/52 feature. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3</td>
   <td>&quot;0&quot;<br></td>
   <td>rdy_sig_mode<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Ready signal mode. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 1:<br><br> </td>
       <td valign=top> DPM_RDY is generated as ready/acknowledge pulse.<br>In this mode, DPM_RDY is only in active state at access end to sign that host device is allowed to finish the<br>current access. If no access to DPM is done or if host device runs DPM access but is not allowed to finish it yet,<br>DPM_RDY will remain in inactive state. </td>
      </tr>
      <tr>
       <td valign=top> 0:<br><br> </td>
       <td valign=top> DPM_RDY is generated as wait/busy state signal.<br>In this mode, DPM_RDY becomes active at access start and will remain active while host device is not allowed to finish the<br>current access. If no access to DPM is done or if host device runs DPM access and allowed to finish it and continue<br>access generation, DPM_RDY will be in inactive state. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>2&nbsp;-&nbsp;1</td>
   <td>&quot;00&quot;<br></td>
   <td>rdy_drv_mode<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Ready generation mode. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 00: </td>
       <td valign=top> ready signal generation is disabled (High-Impedance mode). </td>
      </tr>
      <tr>
       <td valign=top> 01: </td>
       <td valign=top> ready is driven when active and inactive. Never highZ. (Push-Pull mode) </td>
      </tr>
      <tr>
       <td valign=top> 10:<br><br><br><br><br> </td>
       <td valign=top> ready is driven when active and for a short time when inactive-phase starts for fast<br>busy to ready signal state change (Sustain-Tristate mode).<br>Inactive-phase ready driving time (tRPm02, tRPm12) depends on rdy_sig_mode:<br>For rdy_sig_mode=0 this time (tRPm02) is 10ns.<br>For rdy_sig_mode=1 this time (tRPm12) depends on programmed input signal<br>filtering (register dpm_timing_cfg bit filter): If filtering is disabled tRPm12 is 20ns to 30ns,<br>if input filtering is enabled,&nbsp;&nbsp;tRPm12 is 30ns to 40ns. </td>
      </tr>
      <tr>
       <td valign=top> 11: </td>
       <td valign=top> ready is only driven when cycle active (Open-Drain/Open-Source mode). </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mode 2 and 3 are reordered in comparison to netX100/500/50. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;1&quot;<br></td>
   <td>rdy_pol<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Ready signal ready-state polarity. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> DPM is ready when external RDY-signal is high. </td>
      </tr>
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> DPM is busy when external RDY-signal is high. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_status"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_status</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Status Register.<br>DPM access errors can generate IRQ for host device (view DPM IRQ registers further down). For<br>error handling, the address an error occurred with is logged in dpm_status_err_addr register. Error bits can be cleared by<br>access to dpm_status_err_reset register. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note<br><br><br><br><br><br><br><br><br><br><br><br><br><br> </td>
       <td valign=top> &nbsp;for 'bus_conflict_rd_addr_err', 'bus_conflict_rd_err' and 'bus_conflict_wr_err':<br>Bus-conflict error detection is basically implemented as debug feature. Detected errors could be result of hazardous signals, incorrect configured DPM mode or not supported host interfaces. However there could some be some applications where error detection is too strict (see description of 'dis_bus_conflict_err_detect' of 'dpm_misc_cfg'). For that reason bus-conflict error behaviour can be controlled by 'dis_bus_conflict_err_detect' of 'dpm_misc_cfg' register. However, status bits inside this register (and inside 'dpm_status_err_reset') will always be set when an error was detected.<br>When error detection is enabled ('dis_bus_conflict_err_detect' is not set), an error-access will be aborted (ready-signal will be set to ready state when used) and DPM will wait for idle bus (dir_mode==0: deselected or read and write control signal inactive, dir_mode!=0: deselected or all byte-enables inactive). The error IRQ ('dpm_err') will be asserted. Read data of related access will be invalid and write data will be junked.<br>When error detection is disabled ('dis_bus_conflict_err_detect' is set) bus-conflict errors do not assert the 'dpm_err' IRQ, erroneous access will not be aborted and DPM will not wait for bus idle state. I.e. the erroneous access will be finished as read or write. However consequences of an error access are not predictable: Read or write data or address could be invalid.<br>Error detection is disabled by default after power on and must be enabled before usage. </td>
      </tr>
      <tr>
       <td valign=top> Note<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br> </td>
       <td valign=top> &nbsp;for 'rdy_to_err', 'wr_err' and 'rd_err':<br>These errors are basically set when an host access is too fast to be handled by netX internally. NetX internal access times depend on target address area. However there are some address areas where other netX modules have higher access priority than DPM (especially local memories of netX internal CPUs like xPEC or xPIC). Fore these address areas access times could become unpredictable (depending on application running netX inside). Especially when using host devices without ready-signal handshaking (i.e. also serial DPM) where netX access times could not be met under all conditions error detection handling becomes mandatory. It is recommended to check for errors after each access. In error-case the last access must be repeated. If an error occurs permanently the host must stretch external DPM access by inserting wait states. For all other DPM connections this error detection should only be a debug feature.<br>Behaviour of 'wr_err' and 'rd_err' can be additionally controlled by 'dis_access_err_halt' of 'dpm_misc_cfg' register: When error detection is enabled ('dis_access_err_halt' is not set), all read-access after occurrence of a read-error and all write-access after occurrence of a write-error will be ignored. Error states must be reset first before new accesses are performed internally. This is implemented to protect netX from unpredictable results of access errors. However some applications always require access to netX internal address area (e.g. as DPM configuration window 0 for error handling was disabled). For this purpose error-detection could be disabled.<br>DPM error IRQ ('dpm_err') and error-status flags will always be set in error case independent of 'dis_access_err_halt'. Error detection is disabled by default after power on and must be enabled before usage. </td>
      </tr>
      <tr>
       <td valign=top> Note: </td>
       <td valign=top> &nbsp;Errors could be avoided by programming input filtering, burst support or timing. That can be configured by dpm_timing_cfg register. </td>
      </tr>
      <tr>
       <td valign=top> Note:<br> </td>
       <td valign=top> &nbsp;Serial DPM status send on the first byte of a serial access by netX is reordered and bus_conflict-errors are omitted (as they are related to parallel DPM only). Serial DPM status byte is transferred MSB first and contains following information (serial DPM protocol was completely revised for netx51/52 and this is a new netx51/52 feature): </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;bit of first serial byte </td>
       <td valign=top> status information </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7 (MSB) </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abort_err </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;sel_dpm_serial </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rdy_to_err </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wr_err </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rd_err </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 (LSB) </td>
       <td valign=top> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlocked </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br> </td>
       <td valign=top> <br>The first serial transfer after reset is always ignored by the DPM module (due to initial synchronizations between the serial<br>and parallel part of the DPM module). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff00191c<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a1c<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;9</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>8</td>
   <td>abort_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Abort error state (since netX90).<br>The internal netX-logic may return an abort response for an access. Reason could<br>be that the access is blocked by a firewall or it targets address area, which is not<br>available for the DPM. An aborted access means data failure: An aborted read access<br>will return invalid data. Data of an aborted write access is junked by the netX. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> No access was aborted </td>
      </tr>
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> An access was aborted (AHB HRESP returned ERROR). Data is lost. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>7</td>
   <td>sel_dpm_serial<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Serial mode configuration state. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> DPM is in parallel mode. </td>
      </tr>
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> DPM is in serial mode. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Mode selection is done by hif_io_cfg register inside HIF_IO_CTRL address area.<br>Note:<br>&nbsp;&nbsp;&nbsp;After enabling serial DPM 2 dummy read streams must be performed to initialize internal logic. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>6</td>
   <td>bus_conflict_rd_addr_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Parallel DPM read access address change bus error detected.<br>This bit is set if address lines change (after filtering if enabled) during a read access while<br>burst support is not enabled. byte-enables are not included in this error-detection.<br>Note:<br>&nbsp;&nbsp;&nbsp;For additional information view note in register description header. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>5</td>
   <td>bus_conflict_rd_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Parallel DPM read access bus error detected.<br>This bit is set if a read access was started and signals change to write access states.<br>I.e. for dir_mode 0: Write-control (nWR) signal becomes active (low, after filtering if enabled)<br>during a read access.<br>I.e. for dir_mode 1: Direction line (nRD) signal changes to write (low, after filtering if enabled)<br>during a read access.<br>Note:<br>&nbsp;&nbsp;&nbsp;For additional information view note in register description header. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>4</td>
   <td>bus_conflict_wr_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Parallel DPM write access bus error detected.<br>This bit is set if a write access was started and signals change to read access states.<br>I.e. for dir_mode 0: Read-control (nRD) signal becomes active (low, after filtering if enabled)<br>during a write access.<br>I.e. for dir_mode 2: Direction line (nRD) signal changes to read (low, after filtering if enabled)<br>during a write access.<br>Note:<br>&nbsp;&nbsp;&nbsp;For additional information view note in register description header. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>3</td>
   <td>rdy_to_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM_RDY Timeout Error Status Flag.<br>This error could occur if host device tries to access permanently busy netX address area (e.g. netX<br>xPEC program RAM while xPEC is running). To avoid host device stalling DPM_RDY signal is released<br>to ready state after 2048 or 256 system clock cycles (i.e. 20.48us or 2.56us) at least. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> Last access went to netX busy address and was broken to avoid host device stalling. </td>
      </tr>
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> Access was finished successfully by DPM_RDY assertion to ready state. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;For additional information view note in register description header.<br>Note:<br>&nbsp;&nbsp;&nbsp;This flag is not affected by 'dpm_firmware_irq' registers. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>2</td>
   <td>wr_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Write Error Status Flag.<br>Write errors occur if ready signal (DPM_RDY) is not respected by host device and<br>external DPM write access terminated before data could be stored.<br>In some cases certain netX address areas could be busy for not predictable time. If DPM_RDY is<br>not used, check for write error after write access to these areas.<br>In case of write error this bit is set immediately after the appropriate write access. Repeat<br>the write access until no error occurs. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> The external DPM write access was too fast to store write data. Repeat the write access. </td>
      </tr>
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> Write access terminated without error. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;For additional information view note in register description header. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>1</td>
   <td>rd_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Read Error Status Flag.<br>Read errors occur if ready signal (DPM_RDY) is not respected by host device and<br>external DPM read access terminated before read data could be asserted on the external DPM data<br>bus (view also t_rds in dpm_timing_cfg register).<br>In case of read error this bit is set immediately after the appropriate read access. Repeat the<br>read access until no error occurs. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> The external DPM read access was too fast. Repeat the read access. </td>
      </tr>
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> Read data OK. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;For additional information view note in register description header. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>0</td>
   <td>unlocked<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM is locked during netX power up and boot phase.<br>DPM access to other addresses than DPM configuration window 0 cannot be done before this bit is<br>set to 1. Write access to data windows (netX AHB area) will be ignored and read access<br>will deliver invalid data while locked.<br>Poll for 1 after power-up or reset. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_status_err_reset"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_status_err_reset</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Error Status Reset Register.<br>Each flags can be reset by writing a '1' to it. For fast error detection for DPM interfaces without ready usage,<br>reset-on-read-function can be enabled for this register.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;If reset-on-read-function is enabled, this register must be read with a single access as bits are cleared<br>&nbsp;&nbsp;&nbsp;immediately after the access. You should always use a byte access in this case.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;View dpm_status register for detailed error description.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;reset-on-read-function is controlled by enable_flag_reset_on_rd-bit in dpm_misc_cfg-register.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;In cases where internal access time is not predictable and host provides no<br>&nbsp;&nbsp;&nbsp;ready function, it is recommended to enable reset-on-read-function. There is only one access<br>&nbsp;&nbsp;&nbsp;necessary for error detection and clearing this flag then. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001920<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a20<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;9</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>abort_err_rst<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Abort error state (since netX90). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>6</td>
   <td>&quot;0&quot;<br></td>
   <td>bus_conflict_rd_addr_err_rst<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Parallel DPM read access address change bus error detected. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>5</td>
   <td>&quot;0&quot;<br></td>
   <td>bus_conflict_rd_err_rst<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Parallel DPM read access bus error detected. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>bus_conflict_wr_err_rst<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Parallel DPM write access bus error detected. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3</td>
   <td>&quot;0&quot;<br></td>
   <td>rdy_to_err_rst<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM_RDY timeout error. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>wr_err_rst<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM write error detection bit with auto reset function.<br>For fast read error detection this bit can be checked after each read access. If it was set, the read<br>access must be repeated. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>rd_err_rst<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM read error detection bit with auto reset function.<br>For fast write error detection this bit can be checked after each write access. If it was set, the write<br>access must be repeated. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_status_err_addr"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_status_err_addr</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Error Address Status Register. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001924<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a24<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;20</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>19&nbsp;-&nbsp;0</td>
   <td>err_addr<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Access error address.<br>Address of first erroneous access. IRQ handler can use this value to repeat failed accesses after error<br>bits are set in dpm_status or dpm_status_err_reset register. However, only DPM Read Error (rd_err),<br>DPM Write Error (wr_err) and DPM_RDY Timeout Error (rdy_to_err) are cared for address logging.<br>This register is only valid if one of the error bits is set and should be read before error bits are cleared. If no error bit is set,<br>it is updated each access to the current address.<br>Note:<br>&nbsp;&nbsp;&nbsp;Address status during bus conflict errors will not be logged. Bus conflict error status information<br>&nbsp;&nbsp;&nbsp;is for debug purpose of unstable systems. Purpose of this register is primarily access error<br>&nbsp;&nbsp;&nbsp;handling for systems without ready usage. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_misc_cfg"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_misc_cfg</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Configuration Register for some Special Functions. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000006<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001928<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a28<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;3</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;1&quot;<br></td>
   <td>dis_bus_conflict_err_detect<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> This bit controls bus-error-detection.<br>When this bit is set, detected bus errors will only be flagged inside 'dpm_status' register<br>without further action. When this bit is cleared, dpm_error IRQ will be asserted and erroneous<br>accesses are terminated (or ignored) in error case additionally.<br>View also 'bus_conflict' status bits and description of 'dpm_status' register for details.<br>Note:<br>&nbsp;&nbsp;&nbsp;This bit is set by default, but it is strongly recommended to clear it. However keeping<br>&nbsp;&nbsp;&nbsp;this bit set could be helpful for debugging, netx50 compatibility or when<br>&nbsp;&nbsp;&nbsp;DPM configuration window 0 is disabled and not available for error handling.<br>Note:<br>&nbsp;&nbsp;&nbsp;This bit could become necessary to be set for modes with direction signal<br>&nbsp;&nbsp;&nbsp;where byte-enables change (nearly) simultaneously to direction signal (e.g. old Motorola 8bit CPUs).<br>&nbsp;&nbsp;&nbsp;In this case DPM could detect an error at read access end when direction line is<br>&nbsp;&nbsp;&nbsp;already sampled inactive while byte-enables are still sampled active.<br>Note:<br>&nbsp;&nbsp;&nbsp;This is a new netx51/52 feature. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;1&quot;<br></td>
   <td>dis_access_err_halt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Disable halt after access-errors where detected.<br>When this bit is set access-error-detection ('rd_err', 'wr_err' and 'rdy_to_err' status bits<br>of 'dpm_status' register) will be set in error case but following accesses to netX internal<br>address area will not be blocked. Error IRQs will be generated.<br>Note:<br>&nbsp;&nbsp;&nbsp;This bit is set by default, but it is strongly recommended to clear it. However keeping<br>&nbsp;&nbsp;&nbsp;this bit set could be helpful for debugging, netx50 compatibility or when<br>&nbsp;&nbsp;&nbsp;DPM configuration window 0 is disabled and not available for error handling.<br>Note:<br>&nbsp;&nbsp;&nbsp;IRQ 'dpm_err' is asserted in case of access-errors even when this bit is set.<br>Note:<br>&nbsp;&nbsp;&nbsp;This is a new netx51/52 feature. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>enable_flag_reset_on_rd<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Enable Status Flag Reset by reading the 'dpm_status_err_reset' register.<br>When enable_flag_reset_on_rd-bit is set to '1', there is only one access necessary for<br>error detection and clearing the error status bits. In cases where internal access time is<br>not predictable and host provides no ready function, it is recommended to enable reset-on-read-function<br>to minimize traffic. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_io_cfg_misc"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_io_cfg_misc</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM IO Configuration Register.<br>PIO usage of DPM_SIRQ, DPM_DIRQ and DPM_RDY has moved from this register to register'dpm_pio_cfg1' since netx51/52.<br>Signals which should be used as PIOs when netX DPM is active must be selected there. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x000000a0<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff00192c<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a2c<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;8</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>7</td>
   <td>&quot;1&quot;<br></td>
   <td>fiq_oec<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> FIQ/SIRQ output enable controlled. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> FIQ/SIRQ signal is always driven. </td>
      </tr>
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> FIQ/SIRQ signal is only driven when active. Inactive level must be realized by external pull-up or pull-down resistor. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6</td>
   <td>&quot;0&quot;<br></td>
   <td>fiq_pol<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> FIQ/SIRQ signal polarity. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> FIQ/SIRQ is active low. </td>
      </tr>
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> FIQ/SIRQ is active high. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>5</td>
   <td>&quot;1&quot;<br></td>
   <td>irq_oec<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> IRQ output enable controlled. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> IRQ/DIRQ signal is always driven. </td>
      </tr>
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> IRQ/DIRQ signal is only driven when active. Inactive level must be realized by external pull-up or pull-down resistor. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>irq_pol<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> IRQ/DIRQ signal polarity. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> IRQ/DIRQ is active low. </td>
      </tr>
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> IRQ/DIRQ is active high. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3&nbsp;-&nbsp;0</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_tunnel_cfg"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_tunnel_cfg</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Access Tunnel Configuration Register.<br>The DPM Access Tunnel (DATunnel) is a 64 byte (16DWord) address window which can be mapped on any 64 byte boundary of the external<br>visible address space. At the last DWord (offset 0x3C) of the DATunnel the Internal Target Base Address (ITBAddr) can be programmed.<br>This is the base address of the 64 byte tunnel target area inside the full 32-bit netX address range (however some address areas<br>could not be reachable as connections could be cut from the DPM inside the netX data-switch, refer to the data-switch documentation<br>of your netX).<br>By the DWords 0 to 14 of the tunnel the internal netX addresses starting at ITBAddr can be reached. The 'enable'-bit must be active<br>for this (read-only functionality can be configured by 'wp_data'-bit).<br>For access to netX data with ITBAddr DWord offset 15, the lower bits 5 to 2 of the programmed ITBAddr are interpreted as a mapping<br>value. This value will be added to the internal access address before tunnelling (wrapping around at the 64 byte boundary). Hence it<br>is possible to access always 15 of the 16 netX DWord while the one hidden by the ITBAddr can be selected by an appropriate mapping<br>value.<br>The ITBAddr can also be programmed by the 'dpm_itbaddr' register of the configuration window 0 (or the INTLOGIC area). The ITBAddr on<br>tunnel offset 0x3C can be write-protected by the 'wp_itbaddr'-bit. This could be useful to protect the NETX from reconfiguring the<br>tunnel from the host side but provides the host the internal NETX destination address anyhow. However this only makes sense when<br>the configuration window 0 is disabled ('dpm_addr_cfg' register). Otherwise the host could reconfigure the tunnel by the 'dpm_itbaddr'<br>register.<br>Additionally the 'tunnel_all'-bit provides the possibility of tunnelling all 16DWords to the NETX side.<br>To protect the NETX from reconfiguring the tunnel from the host side when the configuration window 0 is enabled, the 'wp_cfg_win'<br>can be activated. Then the tunnel configuration can only be changed from the NETX side (INTLOGIC area) but not from configuration<br>window 0 (in contrast to the 'wp_itbaddr'-bit which protects only offset 0x3C).<br><br>Note:<br>&nbsp;&nbsp;&nbsp;To protect the netX completely from host-access to not permitted address areas it must be ensured that also the remapping<br>&nbsp;&nbsp;&nbsp;of the DPM data windows cannot be changed by the host (refer to registers 'dpm_winX_end' and 'dpm_winX_map').<br><br>External to internal address mapping for DATunnel area can be calculated by following formula:<br>&nbsp;&nbsp;&nbsp;INAAdr = (ITBAddr & 0xffffffc0) + ((EDAAdr + ITBAddr) & 0x3C)<br><br>With: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;INAAdr: </td>
       <td valign=top> Internal netX Access Address </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;ITBAddr: </td>
       <td valign=top> Internal netX 32-bit Tunnel Target Base Address </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;EDAAdr: </td>
       <td valign=top> External DPM Access Address </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> <br>Condition for DATunnel access is:<br>&nbsp;&nbsp;&nbsp;EDAAdr>>6 equals value of bit field 'base' from this register.<br><br>To map netX internal DWord N to invisible last external DWord (15), use mapping value<br>&nbsp;&nbsp;&nbsp;map = (N - 15) & 0xf<br>on bits 5 to 2.<br>Internal to external address offset inside DATunnel area for internal DWord N can be calculated by following formula:<br>&nbsp;&nbsp;&nbsp;External offset = (N*4 - map*4) & 0x3C = (N*4 - ITBAddr) & 0x3C<br><br>Example 1:<br>&nbsp;&nbsp;&nbsp;Access to netX sys_time module by host via DATunnel on external DPM addresses are starting at 0x240.<br>&nbsp;&nbsp;&nbsp;- Set bit field 'base' of this register to 9 (0x240>>6), set 'enable'-bit (and write protection depending on application).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DATunnel now is enabled on external DPM addresses 0x240 to 0x27f.<br>&nbsp;&nbsp;&nbsp;- ITBAddr of netX10 sys_time module is 0x101c1000.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For direct DATunnel to this address, host must write 0x101c1000 to external DPM address 0x27c. This<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can be done e.g. by four byte accesses to 0x27c, 0x27d, 0x27e and 0x27f or by two 16-bit accesses to 0x27c and 0x27e.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Now sys_time module registers 0 to 14 can be accessed on external DPM address 0x240 to 0x27b.<br><br>Example 2:<br>&nbsp;&nbsp;&nbsp;Register 15 of sys_time is hidden by ITBAddr configuration on 0x27c in example 1 but must also be accessed. However, sys_time<br>&nbsp;&nbsp;&nbsp;Register 6 is never kind of interest.<br>&nbsp;&nbsp;&nbsp;- Configure this register like described in example 1.<br>&nbsp;&nbsp;&nbsp;- To map Register 6 (Module offset 6*4) to external offset 0x3C (hidden data on DWord 15),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the following rule must be complied:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x3C + map*4 = 6*4.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;That leads to a mapping value of:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map*4 = (6*4 - 0x3C) & 0x3C = 1C<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hence, write 0x101c101C to DATunnel DWord 15 (external DPM address 0x27c) to map sys_time Register 6 to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hidden DWord 15.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INAAdr now will be derived from EDAAdr before tunnelling as follows:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INAAdr = 0x101c1000 + ((EDAAdr + 0x1C) & 0x3C)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;External offset of Module DWord N results from:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;External offset = (N*4 - 0x1C) & 0x3C<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register 15 of sys_time unit now can be accessed by external DPM address 0x240+((0xf*4-0x1C) & 0x3C) = 0x260 (i.e. Tunnel DWord 8).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register 0&nbsp;&nbsp;of sys_time unit now can be accessed by external DPM address 0x240+((0x0*4-0x1C) & 0x3C) = 0x264 (i.e. Tunnel DWord 9).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register 1&nbsp;&nbsp;of sys_time unit now can be accessed by external DPM address 0x240+((0x1*4-0x1C) & 0x3C) = 0x268 (i.e. Tunnel DWord 10).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and so on.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register 6&nbsp;&nbsp;of sys_time unit can not be accessed as it is hidden by ITBAddr configuration on 0x27c (i.e. Tunnel DWord 15).<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register 7&nbsp;&nbsp;of sys_time unit now can be accessed by external DPM address 0x240+((0x7*4-0x1C) & 0x3C) = 0x240 (i.e. Tunnel DWord 0).<br><br>Note:<br>&nbsp;&nbsp;Access to netX ITBAddr data is done without read ahead and with byte collecting (view adr_dpm_win1_map for details).<br><br>Note:<br>&nbsp;&nbsp;Configuration Window 0 access detection has higher priority than normal DPM Window<br>&nbsp;&nbsp;detection but lower priority than Access Tunnel access detection.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000101<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001938<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a38<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31</td>
   <td>&quot;0&quot;<br></td>
   <td>wp_cfg_win<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Write-protect tunnel configuration inside the configuration window 0. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> The two tunnel configuration registers ('idpm_tunnel_cfg' and 'idpm_itbaddr') can be programmed<br>via configuration window 0 and the INTLOGIC_SYS-IDPM address area. </td>
      </tr>
      <tr>
       <td valign=top> 1:<br> </td>
       <td valign=top> The tunnel configuration registers ('idpm_tunnel_cfg' and 'idpm_itbaddr') cannot<br>be programmed by the host via configuration window 0 (they are read-only for the host there).<br>They can only be programmed via the INTLOGIC_SYS-IDPM address area. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note: Set this bit to protect the NETX from reconfiguring the tunnel by the host when configuration<br>&nbsp;&nbsp;&nbsp;window 0 is activated for the host (e.g. for IRQ handling).<br>Note:<br>&nbsp;&nbsp;&nbsp;The 'wp_cfg_win'-bit is a new feature since netX4000 and netX6. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>30&nbsp;-&nbsp;20</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>19&nbsp;-&nbsp;6</td>
   <td>0x4<br></td>
   <td>base<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Access Tunnel (DATunnel) Base Address divided by 64 on external visible address space.<br>Note:<br>&nbsp;&nbsp;&nbsp;Default setting for tunnel base is starting on external address 0x100. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>5</td>
   <td>&quot;0&quot;<br></td>
   <td>dis_rd_latch<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Disabled read data latch for Tunnel. View 'dis_rd_latch' of 'dpm_win1_map' register for details.<br>Note:<br>&nbsp;&nbsp;&nbsp;This is a new netx51/52 feature. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>byte_area<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Tunnel is byte area or not. View 'byte_area' of 'dpm_win1_map' register for details.<br>Note:<br>&nbsp;&nbsp;&nbsp;This is a new netx51/52 feature. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3</td>
   <td>&quot;0&quot;<br></td>
   <td>tunnel_all<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Enable/disable external access to Internal Target Base Address (ITBAddr) Configuration Register.<br>If this bit is set Internal Target Base Address (ITBAddr) configuration is not available at tunnel<br>offset 0x3C. All 64 tunnel target bytes can be accessed then (no hidden register). Target mapping and address<br>(base and map) will not be changed when enable or disabled.<br>Note:<br>&nbsp;&nbsp;&nbsp;This is a new netx51/52 feature. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>enable<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Enable/disable Access Tunnel function. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>wp_itbaddr<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> ITBAddr is write-protected from host.<br>If this bit is set, ITBAddr (Internal netX 32 bit Tunnel Target Base Address)<br>can only be changed from netX side using dpm_itbaddr address.<br>Write accesses to DWords 0 to 14 of DATunnel will be ignored. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;1&quot;<br></td>
   <td>wp_data<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Access Tunnel function is write-protected from data access (DWords 0 to 14 of DATunnel).<br>Write accesses to DWords 0 to 14 of DATunnel will be ignored.<br>Data write protection for host is enabled by default and can be disabled by clearing this bit. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_itbaddr"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_itbaddr</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Access Tunnel (DATunnel) netX Internal Target Base Address (ITBAddr) Configuration Register.<br>For DPM Access Tunnel (DATunnel) function view description of dpm_tunnel_cfg register.<br>This register contains ITBAddr value that can also be changed by host on last offset 0x3c (last DWord) of<br>external DATunnel area (defined by bit field 'base' in 'dpm_tunnel_cfg' register). However this register can<br>also be write-protected from host if bit 'wp_itbaddr' in 'dpm_tunnel_cfg' register is set.<br>Write protection bits of DATunnel configured in 'dpm_tunnel_cfg' register can also be read from this register. Host<br>can read access rights from these bits on last DWord of external DATunnel address area.<br><br>Note: This register can be write-protected by the 'wp_cfg_win' and the 'wp_itbaddr'-bit of the 'dpm_tunnel_cfg' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000001<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff00193c<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a3c<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;6</td>
   <td>0x0<br></td>
   <td>base<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Internal netX Tunnel Target Base Address (ITBAddr) divided by 64.<br>View description of dpm_tunnel_cfg register. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>5&nbsp;-&nbsp;2</td>
   <td>&quot;0000&quot;<br></td>
   <td>map<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Mapping part of ITBAddr.<br>View description of dpm_tunnel_cfg register. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>-<br></td>
   <td>wp_itbaddr_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> ITBAddr is write-protected from host.<br>This is a read-only bit here. Its setting can be changed in 'dpm_tunnel_cfg' register.<br>View description of dpm_tunnel_cfg register. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>-<br></td>
   <td>wp_data_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Access Tunnel function is write-protected from data access (DWords 0 to 14 of DATunnel).<br>This is a read-only bit here. Its setting can be changed in 'dpm_tunnel_cfg' register.<br>View description of dpm_tunnel_cfg register. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_win1_end"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_win1_end</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Window 1 End Address Configuration Register.<br>Smallest DPM window configuration unit is 128 bytes (i.e. lowest 7 bits of address configuration are always 0).<br>At address 0x0 DPM configuration window is mapped after reset (length: 256 bytes, containing all DPM addresses defined here). Each window starts at<br>window end address of the preceding window. Hence external window 1 start address is 0x100, window 2 starts at value programmed in this register and so on.<br>Windows with programmed end addresses exceeding external address range (view dpm_addr_cfg) can not be accessed by host device.<br><br>Note:<br>&nbsp;&nbsp;This register can be write-protected by the 'wp_cfg_win'-bit of the 'dpm_win1_map' register.<br><br>Note:<br>&nbsp;&nbsp;Configuration Window 0 access detection has higher priority than normal DPM Window<br>&nbsp;&nbsp;detection but lower priority than Access Tunnel access detection.<br><br>Note:<br>&nbsp;&nbsp;Since netX10 window configuration can be done in steps of 128 bytes. In netx5 only steps of 256 bytes are possible.<br><br>Note:<br>&nbsp;&nbsp;Since netX10 there are 4 programmable DPM windows provided. Only for netX5 there are 5 windows.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001940<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a40<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;21</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>20&nbsp;-&nbsp;7</td>
   <td>0x0<br></td>
   <td>win_end<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window 1 End Address divided by 128.<br>Last external address is win_end*128-1.<br>Setting win_end to 0 will disable this window.<br>If programmed external address range (adr_dpm_addr_cfg) is smaller than maximum<br>external address range, access addresses will be zero-expanded for upper unused address lines<br>before window match detection. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6&nbsp;-&nbsp;0</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_win1_map"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_win1_map</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Window 1 Address Map Configuration Register.<br>Smallest DPM window configuration unit is 128 bytes (i.e. lowest 7 bits of address configuration are always 0).<br>For further information view description of 'dpm_win1_end' register.<br><br>Note:<br>&nbsp;&nbsp;Since netX10 window pages of 1MB is supported. For netX5 this was not necessary as all netX5 addresses are in bound of 1MB..<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x01800000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001944<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a44<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;20</td>
   <td>0x18<br></td>
   <td>win_page<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window 1 address page.<br>Internal address space of netX is divided in 1MB pages. Changing win_map allows addressing inside<br>the whole currently set page.<br>Example:<br>&nbsp;&nbsp;&nbsp;Window n starts at 0x400 of external DPM address range (i.e. programmed win_end value of window (n-1) and targets<br>&nbsp;&nbsp;&nbsp;netX address 0x01808000.<br>&nbsp;&nbsp;&nbsp;The programmed value for the related page is 0x018. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>19&nbsp;-&nbsp;7</td>
   <td>0x0<br></td>
   <td>win_map<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window 1 Address Mapping.<br>Internal access address HADDR to netX logic is combined by DPM interface by:<br>HADDR[31:20]: win_page<br>HADDR[19:0]:&nbsp;&nbsp;mapped DPM address. This part of address is defined by programmed win_map value for each window.<br>The value to be programmed is address bits 19 to 0 of netX internal window start address minus start address of the<br>external window (i.e. end address of preceding window) .<br>Example:<br>&nbsp;&nbsp;&nbsp;Window n starts at 0x400 of external DPM address range (i.e. programmed win_end value of window (n-1) and targets<br>&nbsp;&nbsp;&nbsp;netX address 0x01808000.<br>&nbsp;&nbsp;&nbsp;For address calculation only lower 20 bits of netX address are relevant, i.e. 0x08000.<br>&nbsp;&nbsp;&nbsp;The complete 20 bit address map value is then:0x08000-0x400=0x07C00.<br>&nbsp;&nbsp;&nbsp;Hence the programmed 13 bit value must be 0x07C00>>7=0xf8. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>5</td>
   <td>&quot;0&quot;<br></td>
   <td>wp_cfg_win<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Write-protect window configuration inside the configuration window 0. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> All 8 window configuration registers ('dpm_winX_and' and 'dpm_winX_map') can be programmed<br>via configuration window 0 and the INTLOGIC-DPM address area. </td>
      </tr>
      <tr>
       <td valign=top> 1:<br> </td>
       <td valign=top> All 8 window configuration registers ('dpm_winX_and' and 'dpm_winX_map') cannot<br>be programmed by the host via configuration window 0 (they are read-only for the host there).<br>They can only be programmed via the INTLOGIC-DPM address area. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note: Set this bit to protect the NETX from reconfiguring the window mapping by the host when configuration<br>&nbsp;&nbsp;&nbsp;window 0 is activated for the host (e.g. for IRQ handling).<br>Note:<br>&nbsp;&nbsp;&nbsp;To protect the netX completely from host-access to not permitted address areas it must be ensured that also<br>&nbsp;&nbsp;&nbsp;the remapping of the DPM tunnel cannot be changed by the host (refer to register 'dpm_tunnel_cfg').<br>Note:<br>&nbsp;&nbsp;&nbsp;This bit does only exist in the 'dpm_win1_map'-register but not in the registers for the higher windows.<br>&nbsp;&nbsp;&nbsp;However this bit protect all DPM 'dpm_winX_and' and 'dpm_winX_map'-registers from being written via<br>&nbsp;&nbsp;&nbsp;configuration window 0.<br>Note:<br>&nbsp;&nbsp;&nbsp;The 'wp_cfg_win'-bit is a new feature since netX4000 and netX6. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>dis_rd_latch<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window 1 read data latch disable.<br>By default all netX internal read access are done as 32 bit access and read data is latched<br>inside DPM interface. This is done to provide data consistence when host is connected by<br>an interface smaller than 32 bit. Read data latch is updated (new read form netX logic)<br>when host read address is changing to another 32 bit address or if host read access repeats<br>reading the same data within the 32 bit address boundary of prior accesses (e.g. polling).<br>Reading 32 bit status information from netX should be done with byte latching (Example 1).<br>Read data latch can be disabled by setting this bit to avoid special handling of byte (or<br>16 bit) data streams (Example 2).<br>Example 1: Enabled read data latching (default, 'dis_rd_latch' bit is not set):<br>&nbsp;&nbsp;&nbsp;Reading 32 bit systime from netX without data latching will fail when DPM<br>&nbsp;&nbsp;&nbsp;is not 32 bit wide. Considering an 8 bit DPM interface would lead to 4 single<br>&nbsp;&nbsp;&nbsp;host byte read accesses for complete systime. Without data latching systime will<br>&nbsp;&nbsp;&nbsp;be re-read for each byte requested by host. This will lead to invalid data as systime<br>&nbsp;&nbsp;&nbsp;will change between single reads.<br>&nbsp;&nbsp;&nbsp;When data latching is enabled, systime will be read from netX at the first host byte read<br>&nbsp;&nbsp;&nbsp;access. Following 3 host byte reads will receive data from DPM data latch which contains<br>&nbsp;&nbsp;&nbsp;complete 32 bit systime value read at the first access. Host will receive valid systime data.<br>Example 2 Disabled read data latching ('dis_rd_latch' bit is set):<br>&nbsp;&nbsp;&nbsp;Reading a byte stream could fail when it is appended by an application running netX inside<br>&nbsp;&nbsp;&nbsp;could fail. Considering an netX application providing 13 bytes starting at a 32 bit boundary<br>&nbsp;&nbsp;&nbsp;for host and host is reading these bytes. After that netX application is appending new data<br>&nbsp;&nbsp;&nbsp;bytes 14 to 20. When data read latch is enabled host will receive bytes 14 to 16 from data<br>&nbsp;&nbsp;&nbsp;latch. However these bytes are not valid any longer as netX application changed them in<br>&nbsp;&nbsp;&nbsp;background. In this case data latching must be disabled.<br>&nbsp;&nbsp;&nbsp;However reading byte streams is also possible with enabled data latch. In this case<br>&nbsp;&nbsp;&nbsp;host must always read full 32 bit data words (i.e. restart with byte 13 when reading the<br>&nbsp;&nbsp;&nbsp;second part of the stream).<br>Note:<br>&nbsp;&nbsp;&nbsp;When read data latch is disable 'read_ahead' bit should not be set for the same window. Otherwise access<br>&nbsp;&nbsp;&nbsp;timing could decrease dramatically (does not apply to setting of another window).<br>Note:<br>&nbsp;&nbsp;&nbsp;All netX internal read access are performed as 32 bit access.<br>Note:<br>&nbsp;&nbsp;&nbsp;This is a new netx51/52 feature.<br>&nbsp;&nbsp;&nbsp;Behaviour of older netX versions (e.g. netX10) is similar to default setting 0. No functional<br>&nbsp;&nbsp;&nbsp;changes are done for default case. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3&nbsp;-&nbsp;2</td>
   <td>&quot;00&quot;<br></td>
   <td>win_map_alt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window 1 Alternative Address Mapping Configuration.<br>Alternative Address Mapping can be generated by Triple Buffer Managers inside HANDSHAKE_CTRL unit.<br>Coding: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;00 : </td>
       <td valign=top> Alternative Address Mapping disabled. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;01 : </td>
       <td valign=top> Alternative Address Mapping enabled: Use Triple Buffer Manager 0 from HANDSHAKE_CTRL unit. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;10 : </td>
       <td valign=top> Alternative Address Mapping enabled: Use Triple Buffer Manager 1 from HANDSHAKE_CTRL unit. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;11 : </td>
       <td valign=top> reserved </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> If Alternative Address Mapping is enabled, mapping value is taken according to buffer status<br>of related HANDSHAKE_CTRL Triple Buffer Manager as follows. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;buffer status </td>
       <td valign=top> &nbsp;used mapping value </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;00 (buffer 0) </td>
       <td valign=top> &nbsp;win_map entry of this register </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;01 (buffer 1) </td>
       <td valign=top> &nbsp;Alternative win_map value 1 of related HANDSHAKE_CTRL Triple Buffer Manager. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;10 (buffer 2) </td>
       <td valign=top> &nbsp;Alternative win_map value 2 of related HANDSHAKE_CTRL Triple Buffer Manager. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;11 (invalid buffer) </td>
       <td valign=top> &nbsp;win_map entry of this register </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;Alternative Triple Buffer Manager win_map values can be programmed in HANDSHAKE_CTRL address area. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>read_ahead<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Read ahead.<br>If this bit is set, read ahead will be done. This will minimize read cycle time if ready generation is<br>used but could cause problems with read sensitive logic (e.g. FIFOs).<br>Note:<br>&nbsp;&nbsp;&nbsp;Read-ahead should not be enabled when 'dis_rd_latch' bit is set for the same window. Otherwise access<br>&nbsp;&nbsp;&nbsp;timing could decrease dramatically (does not apply to setting of another window). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>byte_area<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window is byte-write area. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> Target area of this window is byte accessible. Any write access are done immediately internally. </td>
      </tr>
      <tr>
       <td valign=top> 0:<br> </td>
       <td valign=top> Target area of this window is 32 bit accessible. Single write accesses are collected until a 32 bit data<br>word (DWord) is received completely from host (write-byte-collecting). Data is written to netX target address when<br>the 32bit data word is complete. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;Since netX51/52 write-byte-collecting buffer is cleared when host is leaving the current 4-byte-address-boundary<br>&nbsp;&nbsp;&nbsp;(e.g. changing address from 0x103 to 0x104). That means all sub-DWord access which should make up the whole DWord<br>&nbsp;&nbsp;&nbsp;must target the same 4-byte-boundary. In prior DPM versions only the last written data determined netX internal<br>&nbsp;&nbsp;&nbsp;access address and there was no check whether all prior written data was written to the same DWord. The<br>&nbsp;&nbsp;&nbsp;address-boundary check is implemented to avoid write-byte-collecting getting confused by single DPM access<br>&nbsp;&nbsp;&nbsp;errors (e.g. by a single missing byte-write).<br>Note:<br>&nbsp;&nbsp;&nbsp;The setting of this bit does not affect read functionality. For details see 'dis_rd_latch' bit description. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_win2_end"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_win2_end</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Window 2 End Address Configuration Register.<br>For detailed information refer to 'dpm_win1_end' register description.<br><br>Note:<br>&nbsp;&nbsp;This register can be write-protected by the 'wp_cfg_win'-bit of the 'dpm_win1_map' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001948<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a48<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;21</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>20&nbsp;-&nbsp;7</td>
   <td>0x0<br></td>
   <td>win_end<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window 2 End Address divided by 128. Last external address is win_end*128-1. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6&nbsp;-&nbsp;0</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_win2_map"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_win2_map</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Window 2 Address Map Configuration Register.<br>For detailed information refer to 'dpm_win1_map' register description.<br><br>Note:<br>&nbsp;&nbsp;This register can be write-protected by the 'wp_cfg_win'-bit of the 'dpm_win1_map' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x01800000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff00194c<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a4c<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;20</td>
   <td>0x18<br></td>
   <td>win_page<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window address page. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>19&nbsp;-&nbsp;7</td>
   <td>0x0<br></td>
   <td>win_map<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window address mapping. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6&nbsp;-&nbsp;5</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>dis_rd_latch<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window read data latch disable. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3&nbsp;-&nbsp;2</td>
   <td>&quot;00&quot;<br></td>
   <td>win_map_alt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window Alternative Address Mapping Configuration. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>read_ahead<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Read ahead. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>byte_area<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window is byte area. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_win3_end"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_win3_end</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Window 3 End Address Configuration Register.<br>For detailed information refer to 'dpm_win1_end' register description.<br><br>Note:<br>&nbsp;&nbsp;This register can be write-protected by the 'wp_cfg_win'-bit of the 'dpm_win1_map' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001950<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a50<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;21</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>20&nbsp;-&nbsp;7</td>
   <td>0x0<br></td>
   <td>win_end<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window 3 End Address divided by 128. Last external address is win_end*128-1. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6&nbsp;-&nbsp;0</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_win3_map"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_win3_map</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Window 3 Address Map Configuration Register.<br>For detailed information refer to 'dpm_win1_map' register description.<br><br>Note:<br>&nbsp;&nbsp;This register can be write-protected by the 'wp_cfg_win'-bit of the 'dpm_win1_map' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x01800000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001954<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a54<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;20</td>
   <td>0x18<br></td>
   <td>win_page<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window address page. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>19&nbsp;-&nbsp;7</td>
   <td>0x0<br></td>
   <td>win_map<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window map address. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6&nbsp;-&nbsp;5</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>dis_rd_latch<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window read data latch disable. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3&nbsp;-&nbsp;2</td>
   <td>&quot;00&quot;<br></td>
   <td>win_map_alt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window Alternative Address Mapping Configuration. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>read_ahead<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Read ahead. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>byte_area<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window is byte area. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_win4_end"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_win4_end</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Window 4 End Address Configuration Register.<br>For detailed information refer to 'dpm_win1_end' register description.<br><br>Note:<br>&nbsp;&nbsp;This register can be write-protected by the 'wp_cfg_win'-bit of the 'dpm_win1_map' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001958<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a58<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;21</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>20&nbsp;-&nbsp;7</td>
   <td>0x0<br></td>
   <td>win_end<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window 4 End Address divided by 128. Last external address is win_end*128-1. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6&nbsp;-&nbsp;0</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_win4_map"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_win4_map</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Window 4 Address Map Configuration Register.<br>For detailed information refer to 'dpm_win1_map' register description.<br><br>Note:<br>&nbsp;&nbsp;This register can be write-protected by the 'wp_cfg_win'-bit of the 'dpm_win1_map' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x01800000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff00195c<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a5c<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;20</td>
   <td>0x18<br></td>
   <td>win_page<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window address page. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>19&nbsp;-&nbsp;7</td>
   <td>0x0<br></td>
   <td>win_map<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window map address. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6&nbsp;-&nbsp;5</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>dis_rd_latch<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window read data latch disable. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3&nbsp;-&nbsp;2</td>
   <td>&quot;00&quot;<br></td>
   <td>win_map_alt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window Alternative Address Mapping Configuration. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>read_ahead<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Read ahead. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>byte_area<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Window is byte area. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_raw0"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_raw0</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Raw (before masking) IRQ Status Register.<br>If a bit is set, the related interrupt is asserted.<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br><br>Important: There are two completely independent sets of IRQ registers: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;IRQ register-set 1: </td>
       <td valign=top> 'dpm_irq_raw' (and related registers e.g. 'dpm_irq_host_dirq_*' registers). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;IRQ register-set 2: </td>
       <td valign=top> 'dpm_firmware_irq_* registers' (netx50 compatible register set: DPM_HOST_INT_EN0,2 DPM_HOST_INT_STA0,2). </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;Programming (masking or clearing IRQs) of one register-set has no impact to the other register-set even if some IRQs<br>&nbsp;&nbsp;&nbsp;can be found in both sets (e.g. com0).<br><br>Note:<br>&nbsp;&nbsp;&nbsp;The 'dpm_sw' IRQ can be controlled by the 'dpm_sw_irq' register for each<br>&nbsp;&nbsp;&nbsp;IRQ target differently, i.e. there are 4 different 'dpm_sw' IRQs internally, one<br>&nbsp;&nbsp;&nbsp;for each IRQ target. However, 'dpm_sw' will be set inside the 'dpm_irq_raw' register here<br>&nbsp;&nbsp;&nbsp;when the 'dpm_sw' is activated for at least one IRQ target. But each IRQ target<br>&nbsp;&nbsp;&nbsp;obtains only the 'dpm_sw' IRQ state programmed for this target inside the 'dpm_sw_irq'<br>&nbsp;&nbsp;&nbsp;register. For an example view description of 'dpm_sw_irq' register.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;&nbsp;The 'test' function is obsolete since netX51/52, the 'dpm_sw' bit can be used instead of this.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;&nbsp;The 'firmware' IRQ can be used to flag handshake and netX firmware system status events to the<br>&nbsp;&nbsp;&nbsp;&nbsp;host. Firmware IRQ generation can be controlled by dpm_firmware_irq_mask register. Detailed<br>&nbsp;&nbsp;&nbsp;&nbsp;firmware IRQ status can be read from dpm_firmware_irq_raw register.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;&nbsp;For all netX modules which are capable generating IRQs for ARM and xPIC, ARM-IRQ is taken here.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001980<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a80<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;17</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>16</td>
   <td>host_hsc8to15<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ for host-side of handshake-cells 8 to 15 from module HANDSHAKE_CTRL interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>15</td>
   <td>host_hsc7<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ for host-side of handshake-cell 7 from module HANDSHAKE_CTRL interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>14</td>
   <td>host_hsc6<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ for host-side of handshake-cell 6 from module HANDSHAKE_CTRL interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>13</td>
   <td>host_hsc5<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ for host-side of handshake-cell 5 from module HANDSHAKE_CTRL interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>12</td>
   <td>host_hsc4<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ for host-side of handshake-cell 4 from module HANDSHAKE_CTRL interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>11</td>
   <td>host_hsc3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ for host-side of handshake-cell 3 from module HANDSHAKE_CTRL interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>10</td>
   <td>host_hsc2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ for host-side of handshake-cell 2 from module HANDSHAKE_CTRL interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>9</td>
   <td>host_hsc1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ for host-side of handshake-cell 1 from module HANDSHAKE_CTRL interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>8</td>
   <td>host_hsc0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ for host-side of handshake-cell 0 from module HANDSHAKE_CTRL interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>7&nbsp;-&nbsp;3</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>2</td>
   <td>firmware<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw combined handshake-cell and SYS_STA firmware IRQ of this DPM module interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>1</td>
   <td>dpm_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw DPM access error IRQ of this DPM module interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>0</td>
   <td>dpm_sw<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw software IRQ of this DPM module for netX IRQ targets (e.g. ARM, xPIC) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_raw1"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_raw1</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Raw (before masking) IRQ Status Register.<br>If a bit is set, the related interrupt is asserted.<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br><br>Important: There are two completely independent sets of IRQ registers: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;IRQ register-set 1: </td>
       <td valign=top> 'dpm_irq_raw' (and related registers e.g. 'dpm_irq_host_dirq_*' registers). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;IRQ register-set 2: </td>
       <td valign=top> 'dpm_firmware_irq_* registers' (netx50 compatible register set: DPM_HOST_INT_EN0,2 DPM_HOST_INT_STA0,2). </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;Programming (masking or clearing IRQs) of one register-set has no impact to the other register-set even if some IRQs<br>&nbsp;&nbsp;&nbsp;can be found in both sets (e.g. com0).<br><br>Note:<br>&nbsp;&nbsp;&nbsp;The 'dpm_sw' IRQ can be controlled by the 'dpm_sw_irq' register for each<br>&nbsp;&nbsp;&nbsp;IRQ target differently, i.e. there are 4 different 'dpm_sw' IRQs internally, one<br>&nbsp;&nbsp;&nbsp;for each IRQ target. However, 'dpm_sw' will be set inside the 'dpm_irq_raw' register here<br>&nbsp;&nbsp;&nbsp;when the 'dpm_sw' is activated for at least one IRQ target. But each IRQ target<br>&nbsp;&nbsp;&nbsp;obtains only the 'dpm_sw' IRQ state programmed for this target inside the 'dpm_sw_irq'<br>&nbsp;&nbsp;&nbsp;register. For an example view description of 'dpm_sw_irq' register.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;&nbsp;The 'test' function is obsolete since netX51/52, the 'dpm_sw' bit can be used instead of this.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;&nbsp;The 'firmware' IRQ can be used to flag handshake and netX firmware system status events to the<br>&nbsp;&nbsp;&nbsp;&nbsp;host. Firmware IRQ generation can be controlled by dpm_firmware_irq_mask register. Detailed<br>&nbsp;&nbsp;&nbsp;&nbsp;firmware IRQ status can be read from dpm_firmware_irq_raw register.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;&nbsp;For all netX modules which are capable generating IRQs for ARM and xPIC, ARM-IRQ is taken here.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001984<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a84<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>30</td>
   <td>phy<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module INT_PHY_CFG (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>29</td>
   <td>clksup<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module CLKSUP (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>28</td>
   <td>bod<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw Brown-out detection IRQ from module ASIC_CTRL (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>27</td>
   <td>CRYPT<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw combined IRQ from module CRYPT (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>26</td>
   <td>GPIO_COM<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw combined IRQ from module GPIO_COM (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>25</td>
   <td>madc_seq3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module MADC (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>24</td>
   <td>madc_seq2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module MADC (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>23</td>
   <td>madc_seq1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module MADC (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>22</td>
   <td>madc_seq0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module MADC (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>21</td>
   <td>eth<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module FETH (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>20</td>
   <td>hif_pio_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module HIF_IO_CTRL (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>19</td>
   <td>sqi<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module SQI (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>18</td>
   <td>lvds2mii1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module LVDS (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>17</td>
   <td>lvds2mii0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module LVDS (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>16</td>
   <td>trigger_lt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module TRIGGER_LT (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>15</td>
   <td>msync1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module XC (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>14</td>
   <td>msync0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module XC (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>13</td>
   <td>com1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module XC (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>12</td>
   <td>com0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module XC (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>11</td>
   <td>nfifo_arm_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module OSAC (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>10</td>
   <td>wdg_xpic_com_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module XPIC_WDG_COM (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>9</td>
   <td>xpic_debug_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module XPIC_DEBUG_COM (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>8</td>
   <td>ecc_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw combined IRQ from module ECC_CRTL_COM and ECC_CTRL (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>7</td>
   <td>i2c1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module I2C_ARM_COM1 (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>6</td>
   <td>i2c0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module I2C_ARM_COM0 (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>5</td>
   <td>uart<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module UART_PL010H (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>4</td>
   <td>mcp_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module MULTI_CPU_PING (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>3</td>
   <td>dmac_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module DMAC (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>2</td>
   <td>wdg_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module WDG_SYS (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>1</td>
   <td>timer_com_systime_s<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw IRQ from module ARM_TIMER (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>0</td>
   <td>ARM_TIMER<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> raw combined IRQ from module ARM_TIMER (only DPM0) interrupt </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_sirq_mask_set0"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_sirq_mask_set0</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Interrupt Mask Register for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ).<br>Write access with '1' sets related interrupt mask bits (enables interrupt request for corresponding interrupt source).<br>Write access with '0' does not influence related interrupt mask bit.<br>Read access shows actual interrupt mask.<br>If a mask bit is set, the related interrupt will activate the IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ).<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001988<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a88<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;17</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>16</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc8to15<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cells 8 to 15 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>15</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc7<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 7 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>14</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc6<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 6 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>13</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc5<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 5 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>12</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc4<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 4 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>11</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 3 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>10</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 2 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>9</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 1 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 0 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7&nbsp;-&nbsp;3</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>firmware<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set combined handshake-cell and SYS_STA firmware IRQ of this DPM module interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>dpm_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set DPM access error IRQ of this DPM module interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>dpm_sw<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set software IRQ of this DPM module for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_sirq_mask_set1"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_sirq_mask_set1</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Interrupt Mask Register for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ).<br>Write access with '1' sets related interrupt mask bits (enables interrupt request for corresponding interrupt source).<br>Write access with '0' does not influence related interrupt mask bit.<br>Read access shows actual interrupt mask.<br>If a mask bit is set, the related interrupt will activate the IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ).<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff00198c<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a8c<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>30</td>
   <td>&quot;0&quot;<br></td>
   <td>phy<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module INT_PHY_CFG (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>29</td>
   <td>&quot;0&quot;<br></td>
   <td>clksup<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module CLKSUP (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>28</td>
   <td>&quot;0&quot;<br></td>
   <td>bod<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set Brown-out detection IRQ from module ASIC_CTRL (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>27</td>
   <td>&quot;0&quot;<br></td>
   <td>CRYPT<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set combined IRQ from module CRYPT (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>26</td>
   <td>&quot;0&quot;<br></td>
   <td>GPIO_COM<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set combined IRQ from module GPIO_COM (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>25</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module MADC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>24</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module MADC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>23</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module MADC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>22</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module MADC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>21</td>
   <td>&quot;0&quot;<br></td>
   <td>eth<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module FETH (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>20</td>
   <td>&quot;0&quot;<br></td>
   <td>hif_pio_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module HIF_IO_CTRL (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>19</td>
   <td>&quot;0&quot;<br></td>
   <td>sqi<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module SQI (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>18</td>
   <td>&quot;0&quot;<br></td>
   <td>lvds2mii1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module LVDS (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>17</td>
   <td>&quot;0&quot;<br></td>
   <td>lvds2mii0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module LVDS (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>16</td>
   <td>&quot;0&quot;<br></td>
   <td>trigger_lt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module TRIGGER_LT (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>15</td>
   <td>&quot;0&quot;<br></td>
   <td>msync1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>14</td>
   <td>&quot;0&quot;<br></td>
   <td>msync0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>13</td>
   <td>&quot;0&quot;<br></td>
   <td>com1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>12</td>
   <td>&quot;0&quot;<br></td>
   <td>com0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>11</td>
   <td>&quot;0&quot;<br></td>
   <td>nfifo_arm_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module OSAC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>10</td>
   <td>&quot;0&quot;<br></td>
   <td>wdg_xpic_com_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XPIC_WDG_COM (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>9</td>
   <td>&quot;0&quot;<br></td>
   <td>xpic_debug_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XPIC_DEBUG_COM (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>ecc_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set combined IRQ from module ECC_CRTL_COM and ECC_CTRL (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7</td>
   <td>&quot;0&quot;<br></td>
   <td>i2c1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module I2C_ARM_COM1 (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6</td>
   <td>&quot;0&quot;<br></td>
   <td>i2c0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module I2C_ARM_COM0 (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>5</td>
   <td>&quot;0&quot;<br></td>
   <td>uart<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module UART_PL010H (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>mcp_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module MULTI_CPU_PING (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3</td>
   <td>&quot;0&quot;<br></td>
   <td>dmac_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module DMAC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>wdg_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module WDG_SYS (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>timer_com_systime_s<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module ARM_TIMER (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>ARM_TIMER<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set combined IRQ from module ARM_TIMER (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_sirq_mask_reset0"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_sirq_mask_reset0</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Interrupt Mask Reset Register for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ).<br>Write access with '1' resets related interrupt mask bits (disables interrupt request for corresponding interrupt source).<br>Write access with '0' does not influence related interrupt mask bit.<br>Read access shows actual interrupt mask.<br>If a mask bit is set, the related interrupt will activate the IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ).<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001990<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a90<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;17</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>16</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc8to15<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cells 8 to 15 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>15</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc7<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 7 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>14</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc6<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 6 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>13</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc5<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 5 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>12</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc4<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 4 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>11</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 3 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>10</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 2 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>9</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 1 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 0 from module HANDSHAKE_CTRL interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7&nbsp;-&nbsp;3</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>firmware<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset combined handshake-cell and SYS_STA firmware IRQ of this DPM module interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>dpm_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset DPM access error IRQ of this DPM module interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>dpm_sw<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset software IRQ of this DPM module for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_sirq_mask_reset1"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_sirq_mask_reset1</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Interrupt Mask Reset Register for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ).<br>Write access with '1' resets related interrupt mask bits (disables interrupt request for corresponding interrupt source).<br>Write access with '0' does not influence related interrupt mask bit.<br>Read access shows actual interrupt mask.<br>If a mask bit is set, the related interrupt will activate the IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ).<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001994<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a94<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>30</td>
   <td>&quot;0&quot;<br></td>
   <td>phy<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module INT_PHY_CFG (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>29</td>
   <td>&quot;0&quot;<br></td>
   <td>clksup<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module CLKSUP (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>28</td>
   <td>&quot;0&quot;<br></td>
   <td>bod<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset Brown-out detection IRQ from module ASIC_CTRL (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>27</td>
   <td>&quot;0&quot;<br></td>
   <td>CRYPT<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset combined IRQ from module CRYPT (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>26</td>
   <td>&quot;0&quot;<br></td>
   <td>GPIO_COM<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset combined IRQ from module GPIO_COM (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>25</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module MADC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>24</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module MADC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>23</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module MADC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>22</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module MADC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>21</td>
   <td>&quot;0&quot;<br></td>
   <td>eth<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module FETH (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>20</td>
   <td>&quot;0&quot;<br></td>
   <td>hif_pio_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module HIF_IO_CTRL (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>19</td>
   <td>&quot;0&quot;<br></td>
   <td>sqi<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module SQI (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>18</td>
   <td>&quot;0&quot;<br></td>
   <td>lvds2mii1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module LVDS (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>17</td>
   <td>&quot;0&quot;<br></td>
   <td>lvds2mii0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module LVDS (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>16</td>
   <td>&quot;0&quot;<br></td>
   <td>trigger_lt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module TRIGGER_LT (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>15</td>
   <td>&quot;0&quot;<br></td>
   <td>msync1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>14</td>
   <td>&quot;0&quot;<br></td>
   <td>msync0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>13</td>
   <td>&quot;0&quot;<br></td>
   <td>com1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>12</td>
   <td>&quot;0&quot;<br></td>
   <td>com0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>11</td>
   <td>&quot;0&quot;<br></td>
   <td>nfifo_arm_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module OSAC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>10</td>
   <td>&quot;0&quot;<br></td>
   <td>wdg_xpic_com_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XPIC_WDG_COM (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>9</td>
   <td>&quot;0&quot;<br></td>
   <td>xpic_debug_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XPIC_DEBUG_COM (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>ecc_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset combined IRQ from module ECC_CRTL_COM and ECC_CTRL (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7</td>
   <td>&quot;0&quot;<br></td>
   <td>i2c1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module I2C_ARM_COM1 (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6</td>
   <td>&quot;0&quot;<br></td>
   <td>i2c0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module I2C_ARM_COM0 (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>5</td>
   <td>&quot;0&quot;<br></td>
   <td>uart<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module UART_PL010H (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>mcp_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module MULTI_CPU_PING (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3</td>
   <td>&quot;0&quot;<br></td>
   <td>dmac_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module DMAC (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>wdg_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module WDG_SYS (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>timer_com_systime_s<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module ARM_TIMER (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>ARM_TIMER<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset combined IRQ from module ARM_TIMER (only DPM0) interrupt mask for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_sirq_masked0"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_sirq_masked0</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Masked Interrupt Status Register for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ).<br>A bit is set, when the related mask bit is set in 'dpm_irq_host_sirq_mask'-register and the related interrupt is asserted.<br>IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) is asserted if at least one bit is set here.<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff001998<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a98<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;17</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>16</td>
   <td>host_hsc8to15<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cells 8 to 15 from module HANDSHAKE_CTRL interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>15</td>
   <td>host_hsc7<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 7 from module HANDSHAKE_CTRL interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>14</td>
   <td>host_hsc6<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 6 from module HANDSHAKE_CTRL interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>13</td>
   <td>host_hsc5<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 5 from module HANDSHAKE_CTRL interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>12</td>
   <td>host_hsc4<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 4 from module HANDSHAKE_CTRL interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>11</td>
   <td>host_hsc3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 3 from module HANDSHAKE_CTRL interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>10</td>
   <td>host_hsc2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 2 from module HANDSHAKE_CTRL interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>9</td>
   <td>host_hsc1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 1 from module HANDSHAKE_CTRL interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>8</td>
   <td>host_hsc0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 0 from module HANDSHAKE_CTRL interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>7&nbsp;-&nbsp;3</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>2</td>
   <td>firmware<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked combined handshake-cell and SYS_STA firmware IRQ of this DPM module interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>1</td>
   <td>dpm_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked DPM access error IRQ of this DPM module interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>0</td>
   <td>dpm_sw<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked software IRQ of this DPM module for netX IRQ targets (e.g. ARM, xPIC) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_sirq_masked1"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_sirq_masked1</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Masked Interrupt Status Register for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ).<br>A bit is set, when the related mask bit is set in 'dpm_irq_host_sirq_mask'-register and the related interrupt is asserted.<br>IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) is asserted if at least one bit is set here.<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff00199c<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001a9c<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>30</td>
   <td>phy<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module INT_PHY_CFG (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>29</td>
   <td>clksup<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module CLKSUP (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>28</td>
   <td>bod<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked Brown-out detection IRQ from module ASIC_CTRL (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>27</td>
   <td>CRYPT<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked combined IRQ from module CRYPT (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>26</td>
   <td>GPIO_COM<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked combined IRQ from module GPIO_COM (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>25</td>
   <td>madc_seq3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module MADC (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>24</td>
   <td>madc_seq2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module MADC (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>23</td>
   <td>madc_seq1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module MADC (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>22</td>
   <td>madc_seq0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module MADC (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>21</td>
   <td>eth<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module FETH (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>20</td>
   <td>hif_pio_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module HIF_IO_CTRL (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>19</td>
   <td>sqi<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module SQI (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>18</td>
   <td>lvds2mii1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module LVDS (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>17</td>
   <td>lvds2mii0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module LVDS (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>16</td>
   <td>trigger_lt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module TRIGGER_LT (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>15</td>
   <td>msync1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XC (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>14</td>
   <td>msync0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XC (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>13</td>
   <td>com1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XC (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>12</td>
   <td>com0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XC (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>11</td>
   <td>nfifo_arm_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module OSAC (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>10</td>
   <td>wdg_xpic_com_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XPIC_WDG_COM (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>9</td>
   <td>xpic_debug_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XPIC_DEBUG_COM (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>8</td>
   <td>ecc_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked combined IRQ from module ECC_CRTL_COM and ECC_CTRL (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>7</td>
   <td>i2c1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module I2C_ARM_COM1 (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>6</td>
   <td>i2c0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module I2C_ARM_COM0 (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>5</td>
   <td>uart<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module UART_PL010H (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>4</td>
   <td>mcp_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module MULTI_CPU_PING (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>3</td>
   <td>dmac_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module DMAC (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>2</td>
   <td>wdg_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module WDG_SYS (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>1</td>
   <td>timer_com_systime_s<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module ARM_TIMER (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>0</td>
   <td>ARM_TIMER<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked combined IRQ from module ARM_TIMER (only DPM0) interrupt state for high-priority netX interrupt output signal (DPM_FIQ/HIF_SIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_dirq_mask_set0"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_dirq_mask_set0</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Interrupt Mask Register for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ).<br>Write access with '1' sets related interrupt mask bits (enables interrupt request for corresponding interrupt source).<br>Write access with '0' does not influence related interrupt mask bit.<br>Read access shows actual interrupt mask.<br>If a mask bit is set, the related interrupt will activate the IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ).<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019a0<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001aa0<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;17</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>16</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc8to15<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cells 8 to 15 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>15</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc7<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 7 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>14</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc6<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 6 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>13</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc5<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 5 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>12</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc4<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 4 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>11</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 3 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>10</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 2 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>9</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 1 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ for host-side of handshake-cell 0 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7&nbsp;-&nbsp;3</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>firmware<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set combined handshake-cell and SYS_STA firmware IRQ of this DPM module interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>dpm_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set DPM access error IRQ of this DPM module interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>dpm_sw<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set software IRQ of this DPM module for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_dirq_mask_set1"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_dirq_mask_set1</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Interrupt Mask Register for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ).<br>Write access with '1' sets related interrupt mask bits (enables interrupt request for corresponding interrupt source).<br>Write access with '0' does not influence related interrupt mask bit.<br>Read access shows actual interrupt mask.<br>If a mask bit is set, the related interrupt will activate the IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ).<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019a4<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001aa4<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>30</td>
   <td>&quot;0&quot;<br></td>
   <td>phy<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module INT_PHY_CFG (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>29</td>
   <td>&quot;0&quot;<br></td>
   <td>clksup<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module CLKSUP (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>28</td>
   <td>&quot;0&quot;<br></td>
   <td>bod<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set Brown-out detection IRQ from module ASIC_CTRL (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>27</td>
   <td>&quot;0&quot;<br></td>
   <td>CRYPT<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set combined IRQ from module CRYPT (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>26</td>
   <td>&quot;0&quot;<br></td>
   <td>GPIO_COM<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set combined IRQ from module GPIO_COM (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>25</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module MADC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>24</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module MADC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>23</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module MADC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>22</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module MADC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>21</td>
   <td>&quot;0&quot;<br></td>
   <td>eth<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module FETH (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>20</td>
   <td>&quot;0&quot;<br></td>
   <td>hif_pio_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module HIF_IO_CTRL (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>19</td>
   <td>&quot;0&quot;<br></td>
   <td>sqi<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module SQI (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>18</td>
   <td>&quot;0&quot;<br></td>
   <td>lvds2mii1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module LVDS (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>17</td>
   <td>&quot;0&quot;<br></td>
   <td>lvds2mii0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module LVDS (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>16</td>
   <td>&quot;0&quot;<br></td>
   <td>trigger_lt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module TRIGGER_LT (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>15</td>
   <td>&quot;0&quot;<br></td>
   <td>msync1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>14</td>
   <td>&quot;0&quot;<br></td>
   <td>msync0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>13</td>
   <td>&quot;0&quot;<br></td>
   <td>com1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>12</td>
   <td>&quot;0&quot;<br></td>
   <td>com0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>11</td>
   <td>&quot;0&quot;<br></td>
   <td>nfifo_arm_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module OSAC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>10</td>
   <td>&quot;0&quot;<br></td>
   <td>wdg_xpic_com_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XPIC_WDG_COM (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>9</td>
   <td>&quot;0&quot;<br></td>
   <td>xpic_debug_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module XPIC_DEBUG_COM (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>ecc_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set combined IRQ from module ECC_CRTL_COM and ECC_CTRL (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7</td>
   <td>&quot;0&quot;<br></td>
   <td>i2c1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module I2C_ARM_COM1 (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6</td>
   <td>&quot;0&quot;<br></td>
   <td>i2c0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module I2C_ARM_COM0 (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>5</td>
   <td>&quot;0&quot;<br></td>
   <td>uart<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module UART_PL010H (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>mcp_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module MULTI_CPU_PING (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3</td>
   <td>&quot;0&quot;<br></td>
   <td>dmac_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module DMAC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>wdg_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module WDG_SYS (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>timer_com_systime_s<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set IRQ from module ARM_TIMER (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>ARM_TIMER<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> set combined IRQ from module ARM_TIMER (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_dirq_mask_reset0"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_dirq_mask_reset0</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Interrupt Mask Reset Register for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ).<br>Write access with '1' resets related interrupt mask bits (disables interrupt request for corresponding interrupt source).<br>Write access with '0' does not influence related interrupt mask bit.<br>Read access shows actual interrupt mask.<br>If a mask bit is set, the related interrupt will activate the IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ).<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019a8<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001aa8<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;17</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>16</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc8to15<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cells 8 to 15 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>15</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc7<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 7 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>14</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc6<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 6 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>13</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc5<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 5 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>12</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc4<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 4 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>11</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 3 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>10</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 2 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>9</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 1 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>host_hsc0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ for host-side of handshake-cell 0 from module HANDSHAKE_CTRL interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7&nbsp;-&nbsp;3</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>firmware<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset combined handshake-cell and SYS_STA firmware IRQ of this DPM module interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>dpm_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset DPM access error IRQ of this DPM module interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>dpm_sw<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset software IRQ of this DPM module for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_dirq_mask_reset1"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_dirq_mask_reset1</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Interrupt Mask Reset Register for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ).<br>Write access with '1' resets related interrupt mask bits (disables interrupt request for corresponding interrupt source).<br>Write access with '0' does not influence related interrupt mask bit.<br>Read access shows actual interrupt mask.<br>If a mask bit is set, the related interrupt will activate the IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ).<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019ac<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001aac<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>30</td>
   <td>&quot;0&quot;<br></td>
   <td>phy<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module INT_PHY_CFG (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>29</td>
   <td>&quot;0&quot;<br></td>
   <td>clksup<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module CLKSUP (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>28</td>
   <td>&quot;0&quot;<br></td>
   <td>bod<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset Brown-out detection IRQ from module ASIC_CTRL (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>27</td>
   <td>&quot;0&quot;<br></td>
   <td>CRYPT<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset combined IRQ from module CRYPT (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>26</td>
   <td>&quot;0&quot;<br></td>
   <td>GPIO_COM<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset combined IRQ from module GPIO_COM (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>25</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module MADC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>24</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module MADC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>23</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module MADC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>22</td>
   <td>&quot;0&quot;<br></td>
   <td>madc_seq0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module MADC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>21</td>
   <td>&quot;0&quot;<br></td>
   <td>eth<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module FETH (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>20</td>
   <td>&quot;0&quot;<br></td>
   <td>hif_pio_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module HIF_IO_CTRL (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>19</td>
   <td>&quot;0&quot;<br></td>
   <td>sqi<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module SQI (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>18</td>
   <td>&quot;0&quot;<br></td>
   <td>lvds2mii1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module LVDS (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>17</td>
   <td>&quot;0&quot;<br></td>
   <td>lvds2mii0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module LVDS (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>16</td>
   <td>&quot;0&quot;<br></td>
   <td>trigger_lt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module TRIGGER_LT (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>15</td>
   <td>&quot;0&quot;<br></td>
   <td>msync1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>14</td>
   <td>&quot;0&quot;<br></td>
   <td>msync0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>13</td>
   <td>&quot;0&quot;<br></td>
   <td>com1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>12</td>
   <td>&quot;0&quot;<br></td>
   <td>com0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>11</td>
   <td>&quot;0&quot;<br></td>
   <td>nfifo_arm_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module OSAC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>10</td>
   <td>&quot;0&quot;<br></td>
   <td>wdg_xpic_com_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XPIC_WDG_COM (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>9</td>
   <td>&quot;0&quot;<br></td>
   <td>xpic_debug_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module XPIC_DEBUG_COM (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>ecc_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset combined IRQ from module ECC_CRTL_COM and ECC_CTRL (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7</td>
   <td>&quot;0&quot;<br></td>
   <td>i2c1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module I2C_ARM_COM1 (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6</td>
   <td>&quot;0&quot;<br></td>
   <td>i2c0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module I2C_ARM_COM0 (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>5</td>
   <td>&quot;0&quot;<br></td>
   <td>uart<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module UART_PL010H (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>mcp_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module MULTI_CPU_PING (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3</td>
   <td>&quot;0&quot;<br></td>
   <td>dmac_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module DMAC (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>wdg_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module WDG_SYS (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>timer_com_systime_s<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset IRQ from module ARM_TIMER (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>ARM_TIMER<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reset combined IRQ from module ARM_TIMER (only DPM0) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_dirq_masked0"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_dirq_masked0</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Masked Interrupt Status Register for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ).<br>A bit is set, when the related mask bit is set in 'dpm_irq_host_dirq_mask'-register and the related interrupt is asserted.<br>IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) is asserted if at least one bit is set here.<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019b0<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001ab0<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;17</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>16</td>
   <td>host_hsc8to15<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cells 8 to 15 from module HANDSHAKE_CTRL interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>15</td>
   <td>host_hsc7<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 7 from module HANDSHAKE_CTRL interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>14</td>
   <td>host_hsc6<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 6 from module HANDSHAKE_CTRL interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>13</td>
   <td>host_hsc5<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 5 from module HANDSHAKE_CTRL interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>12</td>
   <td>host_hsc4<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 4 from module HANDSHAKE_CTRL interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>11</td>
   <td>host_hsc3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 3 from module HANDSHAKE_CTRL interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>10</td>
   <td>host_hsc2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 2 from module HANDSHAKE_CTRL interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>9</td>
   <td>host_hsc1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 1 from module HANDSHAKE_CTRL interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>8</td>
   <td>host_hsc0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ for host-side of handshake-cell 0 from module HANDSHAKE_CTRL interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>7&nbsp;-&nbsp;3</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>2</td>
   <td>firmware<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked combined handshake-cell and SYS_STA firmware IRQ of this DPM module interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>1</td>
   <td>dpm_err<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked DPM access error IRQ of this DPM module interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>0</td>
   <td>dpm_sw<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked software IRQ of this DPM module for netX IRQ targets (e.g. ARM, xPIC) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_irq_host_dirq_masked1"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_irq_host_dirq_masked1</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Masked Interrupt Status Register for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ).<br>A bit is set, when the related mask bit is set in 'dpm_irq_host_dirq_mask'-register and the related interrupt is asserted.<br>IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) is asserted if at least one bit is set here.<br>Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here.<br>To release IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) without clearing interrupt in module, reset related mask bit to 0.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For further information view description of 'dpm_irq_raw' register.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019b4<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001ab4<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>30</td>
   <td>phy<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module INT_PHY_CFG (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>29</td>
   <td>clksup<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module CLKSUP (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>28</td>
   <td>bod<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked Brown-out detection IRQ from module ASIC_CTRL (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>27</td>
   <td>CRYPT<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked combined IRQ from module CRYPT (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>26</td>
   <td>GPIO_COM<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked combined IRQ from module GPIO_COM (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>25</td>
   <td>madc_seq3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module MADC (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>24</td>
   <td>madc_seq2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module MADC (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>23</td>
   <td>madc_seq1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module MADC (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>22</td>
   <td>madc_seq0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module MADC (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>21</td>
   <td>eth<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module FETH (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>20</td>
   <td>hif_pio_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module HIF_IO_CTRL (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>19</td>
   <td>sqi<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module SQI (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>18</td>
   <td>lvds2mii1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module LVDS (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>17</td>
   <td>lvds2mii0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module LVDS (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>16</td>
   <td>trigger_lt<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module TRIGGER_LT (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>15</td>
   <td>msync1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XC (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>14</td>
   <td>msync0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XC (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>13</td>
   <td>com1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XC (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>12</td>
   <td>com0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XC (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>11</td>
   <td>nfifo_arm_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module OSAC (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>10</td>
   <td>wdg_xpic_com_arm<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XPIC_WDG_COM (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>9</td>
   <td>xpic_debug_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module XPIC_DEBUG_COM (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>8</td>
   <td>ecc_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked combined IRQ from module ECC_CRTL_COM and ECC_CTRL (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>7</td>
   <td>i2c1_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module I2C_ARM_COM1 (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>6</td>
   <td>i2c0_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module I2C_ARM_COM0 (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>5</td>
   <td>uart<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module UART_PL010H (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>4</td>
   <td>mcp_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module MULTI_CPU_PING (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>3</td>
   <td>dmac_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module DMAC (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>2</td>
   <td>wdg_com<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module WDG_SYS (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>1</td>
   <td>timer_com_systime_s<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked IRQ from module ARM_TIMER (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>0</td>
   <td>ARM_TIMER<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> masked combined IRQ from module ARM_TIMER (only DPM0) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_sw_irq"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_sw_irq</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Register for Software Interrupt Generation.<br>To propagate interrupt states from this register to the interrupt target the 'dpm_sw' bit must<br>be set inside the appropriate interrupt mask (e.g. 'dpm_irq_arm_mask_set' register).<br><br>Example:<br>&nbsp;&nbsp;&nbsp;The 'dpm_sw' IRQs can be used by the host to flag one IRQ to the ARM by<br>&nbsp;&nbsp;&nbsp;setting the arm-dpm_sw and another IRQ to the xPIC by setting the xpic-dpm_sw. The<br>&nbsp;&nbsp;&nbsp;ARM can use at the same time the irq-dpm_sw to flag an IRQ to the host while the<br>&nbsp;&nbsp;&nbsp;xPIC could use the fiq-dpm_sw to flag another IRQ to the host.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For each netX interrupt target&nbsp;&nbsp;there is a set and a reset bit provided to avoid read-modify-write sequences.<br>&nbsp;&nbsp;&nbsp;When both (set and reset) bits are set for the same target, the related interrupt will be set (set will win).<br>&nbsp;&nbsp;&nbsp;Reset bits are always 0 on read. Set-bits show current interrupt status when read.<br>Note:<br>&nbsp;&nbsp;&nbsp;This register is a new netx51/52 feature.. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019b8<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001ab8<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;10</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>9</td>
   <td>&quot;0&quot;<br></td>
   <td>reset_host_dirq<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Reset 'dpm_sw' IRQ for DIRQ/IRQ-signal (always 0 when read) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>reset_host_sirq<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Reset 'dpm_sw' IRQ for SIRQ/FIQ-signal (always 0 when read) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7&nbsp;-&nbsp;2</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>set_host_dirq<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Set 'dpm_sw' IRQ for DIRQ/IRQ-signal (current 'dpm_sw' status for host_dirq when read) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>set_host_sirq<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Set 'dpm_sw' IRQ for SIRQ/FIQ-signal (current 'dpm_sw' status for host_sirq when read) </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_crc"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_crc</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM CRC for access to NETX data (window1-4) </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0xffffffff<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019bc<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001abc<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;16</td>
   <td>0xffff<br></td>
   <td>crc_wdata<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Provides the current CRC of data written to DPM windows 1-4 since last write-CRC clear.<br>Write 0x1 to this bit field to clear write-CRC generation to restart CRC for a new write data. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>15&nbsp;-&nbsp;0</td>
   <td>0xffff<br></td>
   <td>crc_rdata<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Provides the current CRC of data read from DPM windows 1-4 since last read-CRC clear.<br>Write 0x1 to this bit field to clear read-CRC generation to restart CRC for a new read data. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_reserved_netx50_wgd_host_timeout"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_reserved_netx50_wgd_host_timeout</b></font><br><font size="-2">(DPM_HOST_WDG_HOST_TIMEOUT)</font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Address reserved for netx50 DPM_HOST_WDG_HOST_TIMEOUT. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019c0<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001ac0<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;0</td>
   <td>zero_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reserved for netx50 DPM_HOST_WDG_HOST_TIMEOUT. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_reserved_netx50_wgd_host_trigger"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_reserved_netx50_wgd_host_trigger</b></font><br><font size="-2">(DPM_HOST_WDG_HOST_TRIG)</font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Address reserved for netx50 DPM_HOST_WDG_HOST_TRIG. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019c4<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001ac4<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;0</td>
   <td>zero_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reserved for netx50 DPM_HOST_WDG_HOST_TRIG. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_reserved_netx50_wgd_netx_timeout"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_reserved_netx50_wgd_netx_timeout</b></font><br><font size="-2">(DPM_HOST_WDG_ARM_TIMEOUT)</font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Address reserved for netx50 DPM_HOST_WDG_ARM_TIMEOUT. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019c8<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001ac8<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;0</td>
   <td>zero_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reserved for netx50 DPM_HOST_WDG_ARM_TIMEOUT. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_sys_sta_bigend16"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_sys_sta_bigend16</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM System Status Information Register in big endianess 16 data mapping.<br>Read-only, use dpm_sys_sta for programming.<br>This register can be used for firmware status information.<br>Reading this register data can be done from uninitialized DPM interface in the same way<br>as reading netx version (adr_dpm_netx_version_bigend16, adr_dpm_netx_version) by using dpm_sys_sta_bigend16 register. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019cc<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001acc<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;16</td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td colspan=2>15&nbsp;-&nbsp;12</td>
   <td>HOST_STATE_swap_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Bit field for Hilscher firmware compatibility. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>11&nbsp;-&nbsp;10</td>
   <td>NETX_STATE_swap_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Bit field for Hilscher firmware compatibility. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>9</td>
   <td>RUN_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Output state of netX RUN LED IO. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>8</td>
   <td>RDY_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Output state of netX RDY LED IO. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>7&nbsp;-&nbsp;0</td>
   <td>NETX_STA_CODE_swap_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Bit field for Hilscher firmware compatibility. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_reserved_netx50_timer_ctrl"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_reserved_netx50_timer_ctrl</b></font><br><font size="-2">(DPM_HOST_TMR_CTRL)</font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Address reserved for netx50 DPM_HOST_TMR_CTRL. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019d0<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001ad0<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;0</td>
   <td>zero_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reserved for netx50 DPM_HOST_TMR_CTRL. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_reserved_netx50_timer_start_val"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_reserved_netx50_timer_start_val</b></font><br><font size="-2">(DPM_HOST_TMR_START_VAL)</font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Address reserved for netx50 DPM_HOST_TMR_START_VAL. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019d4<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001ad4<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;0</td>
   <td>zero_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reserved for netx50 DPM_HOST_TMR_START_VAL. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_sys_sta"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_sys_sta</b></font><br><font size="-2">(DPM_HOST_SYS_STAT)</font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM System Status Information Register.<br>This register can be used for firmware status information.<br>Reading this register data can be done from uninitialized DPM interface in the same way<br>as reading netx version (adr_dpm_netx_version_bigend16, adr_dpm_netx_version) by using dpm_sys_sta_bigend16 register.<br><br>Note:<br>&nbsp;&nbsp;&nbsp;For DPM0 This register is compatible to netx50 DPM_HOST_SYS_STAT register<br>&nbsp;&nbsp;&nbsp;Only the HOST_STATE-bits of DPM0 can be read from the 'netx_status'-register inside ASIC_CTRL address area.<br>&nbsp;&nbsp;&nbsp;The HOST_STATE-bits of DPM1 and IDPM can not be read from the 'netx_status'-register inside<br>&nbsp;&nbsp;&nbsp;ASIC_CTRL address area.<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019d8<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001ad8<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;16</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>15&nbsp;-&nbsp;8</td>
   <td>-<br></td>
   <td>NETX_STA_CODE_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Bit field for Hilscher firmware compatibility (read only).<br>Note: This bit field can be changed by 'netx_status'-register inside ASIC_CTRL address area. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7&nbsp;-&nbsp;4</td>
   <td>&quot;0000&quot;<br></td>
   <td>HOST_STATE<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Bit field for Hilscher firmware compatibility.<br>Note: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;For DPM0: </td>
       <td valign=top> This bit field can be read also at 'netx_status'-register inside ASIC_CTRL address area. </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;For DPM1: </td>
       <td valign=top> This bit field can not be read also at 'netx_status'-register inside ASIC_CTRL address area. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3&nbsp;-&nbsp;2</td>
   <td>-<br></td>
   <td>NETX_STATE_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Bit field for Hilscher firmware compatibility.<br>Note: This bit field can be changed by 'netx_status'-register inside ASIC_CTRL address area. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>-<br></td>
   <td>RUN_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Output state of netX RUN LED IO.<br>Note: This bit field can be changed by 'rdy_run_cfg'-register inside ASIC_CTRL address area. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>-<br></td>
   <td>RDY_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Output state of netX RDY LED IO.<br>Note: This bit field can be changed by 'rdy_run_cfg'-register inside ASIC_CTRL address area. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_reset_request"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_reset_request</b></font><br><font size="-2">(DPM_HOST_RESET_REQ)</font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Reset Request Register.<br><br>Note: This register is compatible to netx50 DPM_HOST_RESET_REQ register<br> </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019dc<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001adc<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31&nbsp;-&nbsp;8</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>7&nbsp;-&nbsp;0</td>
   <td>&quot;00000000&quot;<br></td>
   <td>reset_key<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Reset key sequence register.<br>A netx hardware reset is generated if the following sequence is written to this register: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;1st access: </td>
       <td valign=top> write 0x00 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;2nd access: </td>
       <td valign=top> write 0x01 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;3rd access: </td>
       <td valign=top> write 0x03 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;4th access: </td>
       <td valign=top> write 0x07 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;5th access: </td>
       <td valign=top> write 0x0f </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;6th access: </td>
       <td valign=top> write 0x1f </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;7th access: </td>
       <td valign=top> write 0x3f </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;8th access: </td>
       <td valign=top> write 0x7f </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> To issue a reset the sequence must not be interrupted by a write access to another register<br>of this DPM module register area. Writing 0x00 will always restart the sequence.<br>Reading this register will always provide the next write data. Hence it is also possible<br>performing 8 times a read-write sequence to this register (however this is not required,<br>simply writing the sequence will also succeed).<br>Writing any other value than the next expected by the DPM module, the internal reset FSM will<br>be cleared and the register will return 0x00 for the next read. The FSM will also be cleared<br>if the sequence is interrupted by a write access to any other register of this DPM register<br>area. The sequence must be restarted with the 1st access (writing 0x00) in this case.<br>Note:<br>&nbsp;&nbsp;&nbsp;The DPM reset request is internally a level-signal, not only a pulse. Additionally the<br>&nbsp;&nbsp;&nbsp;DPM reset request could be masked (disabled) by the global reset controller (netX4000).<br>&nbsp;&nbsp;&nbsp;If the DPM reset request is disabled globally but issued by the DPM module there are two<br>&nbsp;&nbsp;&nbsp;possibilities to get out of this: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;1.: </td>
       <td valign=top> Enable the DPM reset in the global reset controller. The NETX will be reset then<br>immediately (typically this must be done by the NETX-side CPU and cannot be done by a host). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;2.:<br> </td>
       <td valign=top> Write 0x00 (or any other value except 0xFF) to this register or perform a write<br>access to any other register of this DPM register area. This will clear the DPM<br>reset FSM and the reset request of this DPM module to the global reset controller. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;For netx10 a 9th access (write 0xff) was necessary to perform a reset&nbsp;&nbsp;This access<br>&nbsp;&nbsp;is not netx50 compatible and not required any longer since netx51/52. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_firmware_irq_raw"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_firmware_irq_raw</b></font><br><font size="-2">(DPM_HOST_INT_STAT0)</font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 1st netx50 compatible DPM Interrupt Status Register (related to 'dpm_firmware_irq_mask'-register).<br>Writing a '1' to an IRQ flag will clear the Interrupt. This is always done even if related bit inside<br>'dpm_firmware_irq_mask'-register is not set (this is compatible to netx50).<br><br>Important: There are two completely independent sets of IRQ registers: </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;IRQ register-set 1: </td>
       <td valign=top> 'dpm_irq_raw' (and related registers e.g. 'dpm_irq_host_dirq_*' registers). </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;IRQ register-set 2: </td>
       <td valign=top> 'dpm_firmware_irq_* registers' (netx50 compatible register set: DPM_HOST_INT_EN0,2 DPM_HOST_INT_STA0,2). </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp;&nbsp;&nbsp;Programming (masking or clearing IRQs) of one register-set has no impact to the other register-set even if some IRQs<br>&nbsp;&nbsp;&nbsp;can be found in both sets (e.g. com0).<br><br>Note: This register is compatible to netx50 DPM_HOST_INT_STAT0 register, however some unused<br>&nbsp;&nbsp;&nbsp;IRQs have been removed.<br><br>Note: The 2nd firmware IRQ register set (dpm_firmware_irq_mask2, DPM_HOST_INT_EN2, dpm_firmware_irq_raw2, DPM_HOST_INT_STAT2)<br>&nbsp;&nbsp;&nbsp;are obsolete since netx4000. Some functions moved to the main DPM IRQ register set (view dpm_irq_raw). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019e0<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001ae0<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31</td>
   <td>&quot;0&quot;<br></td>
   <td>INT_REQ<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Interrupt Request for IRQs handled in this register. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> No Interrupts to host requested by IRQ sources handled in this register. </td>
      </tr>
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> IRQ sources handled in this register request a host IRQ. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note: This bit is masked by INT_EN-bit in dpm_firmware_irq_mask register.<br>&nbsp;&nbsp;&nbsp;For propagation of INT_REQ to host, ARM or xPIC, INT_EN-bit must be set and firmware IRQ<br>&nbsp;&nbsp;&nbsp;must be activated in related dpm_irq_* register. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>30</td>
   <td>-<br></td>
   <td>res_MEM_LCK_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reserved for Memory Lock IRQ flag (not available in this netX version). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>29</td>
   <td>-<br></td>
   <td>res_WDG_NETX_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reserved for netX supervision Watchdog Timeout IRQ flag (not available in this netX version). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>28</td>
   <td>&quot;0&quot;<br></td>
   <td>RDY_TIMEOUT<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM_RDY timeout error was detected.<br>Note:<br>&nbsp;&nbsp;&nbsp;This flag is not affected by 'dpm_status_err' registers. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>27</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>26</td>
   <td>&quot;0&quot;<br></td>
   <td>SYS_STA<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> System Status Change IRQ flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>25</td>
   <td>-<br></td>
   <td>res_TMR_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reserved for Timer IRQ flag (not available in this netX version). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>24</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>23&nbsp;-&nbsp;16</td>
   <td>&quot;00000000&quot;<br></td>
   <td>IRQ_VECTOR<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Interrupt Vector according to status flags generated by enabled IRQ sources. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Code </td>
       <td valign=top> &nbsp;IRQ status </td>
      </tr>
      <tr>
       <td valign=top> 0x00 </td>
       <td valign=top> &nbsp;No IRQ. </td>
      </tr>
      <tr>
       <td valign=top> ---- </td>
       <td valign=top> &nbsp;------- </td>
      </tr>
      <tr>
       <td valign=top> 0x10 </td>
       <td valign=top> &nbsp;Handshake Cell 0 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x11 </td>
       <td valign=top> &nbsp;Handshake Cell 1 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x12 </td>
       <td valign=top> &nbsp;Handshake Cell 2 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x13 </td>
       <td valign=top> &nbsp;Handshake Cell 3 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x14 </td>
       <td valign=top> &nbsp;Handshake Cell 4 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x15 </td>
       <td valign=top> &nbsp;Handshake Cell 5 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x16 </td>
       <td valign=top> &nbsp;Handshake Cell 6 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x17 </td>
       <td valign=top> &nbsp;Handshake Cell 7 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x18 </td>
       <td valign=top> &nbsp;Handshake Cell 8 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x19 </td>
       <td valign=top> &nbsp;Handshake Cell 9 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x1a </td>
       <td valign=top> &nbsp;Handshake Cell 10 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x1b </td>
       <td valign=top> &nbsp;Handshake Cell 11 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x1c </td>
       <td valign=top> &nbsp;Handshake Cell 12 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x1d </td>
       <td valign=top> &nbsp;Handshake Cell 13 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x1e </td>
       <td valign=top> &nbsp;Handshake Cell 14 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> 0x1f </td>
       <td valign=top> &nbsp;Handshake Cell 15 IRQ. </td>
      </tr>
      <tr>
       <td valign=top> ---- </td>
       <td valign=top> &nbsp;------- </td>
      </tr>
      <tr>
       <td valign=top> 0x67 </td>
       <td valign=top> &nbsp;RDY_TIMEOUT IRQ </td>
      </tr>
      <tr>
       <td valign=top> 0x70 </td>
       <td valign=top> &nbsp;SYS_STA IRQ </td>
      </tr>
      <tr>
       <td valign=top> Other </td>
       <td valign=top> &nbsp;values are reserved. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note:<br>&nbsp;&nbsp;&nbsp;The current IRQ state in VECTOR depends only on the single IRQ enable bits. It<br>&nbsp;&nbsp;&nbsp;does not depend on global IRQ enable INT_EN. VECTOR shows always the highest priority enabled<br>&nbsp;&nbsp;&nbsp;flagged IRQ even is INT_EN is '0'. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>15</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT15<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 15 IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>14</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT14<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 14 IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>13</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT13<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 13 IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>12</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT12<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 12 IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>11</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT11<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 11 IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>10</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT10<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 10 IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>9</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT9<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 9&nbsp;&nbsp;IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT8<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 8&nbsp;&nbsp;IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT7<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 7&nbsp;&nbsp;IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT6<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 6&nbsp;&nbsp;IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>5</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT5<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 5&nbsp;&nbsp;IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT4<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 4&nbsp;&nbsp;IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 3&nbsp;&nbsp;IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 2&nbsp;&nbsp;IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 1&nbsp;&nbsp;IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 0&nbsp;&nbsp;IRQ status flag. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_firmware_irq_mask"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_firmware_irq_mask</b></font><br><font size="-2">(DPM_HOST_INT_EN0)</font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM Handshake Interrupt Enable Register.<br>Only netx50 compatible 'dpm_firmware_irq' registers are related to settings of this register.<br><br>Note: This register is compatible to netx50 DPM_HOST_INT_EN0 register, however some unused<br>&nbsp;&nbsp;&nbsp;IRQs have been removed.<br><br>Note: HS_EVENT-bits are not read-only. This is netX50 compliant.<br>&nbsp;&nbsp;&nbsp;Recent netX50 Documentation marks HS_EVENT-bits as read-only. This is an documentation error.<br>&nbsp;&nbsp;&nbsp;For netX50 compatibility, these bits can also be controlled from netX-side in HANDSHAKE_CTRL address area.<br><br>Note: The 2nd firmware IRQ register set (dpm_firmware_irq_mask2, DPM_HOST_INT_EN2, dpm_firmware_irq_raw2, DPM_HOST_INT_STAT2)<br>&nbsp;&nbsp;&nbsp;are obsolete since netx4000. Some functions moved to the main DPM IRQ register set (view dpm_irq_raw). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center>R/W<br></td>
   <td align=left>0x00000000<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019f0<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001af0<br>
   </td>
  </tr>
   <th bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Reset value</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td>31</td>
   <td>&quot;0&quot;<br></td>
   <td>INT_EN<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Interrupt Enable for IRQs handled in this register.<br>Only if this bit is set, global firmware IRQ will be asserted to host CPU, ARM or xPIC<br>by dpm_irq_* registers. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> 0: </td>
       <td valign=top> No Interrupts to host, ARM or xPIC are generated by IRQ sources handled in this register. </td>
      </tr>
      <tr>
       <td valign=top> 1: </td>
       <td valign=top> Enabled IRQ sources handled in this register generate a host, ARM or xPIC IRQ if asserted. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Note: Enable bits for single IRQ events are not affected if this bit is set or reset. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>30</td>
   <td>-<br></td>
   <td>res_MEM_LCK_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reserved for Memory Lock IRQ (not available in this netX version). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>29</td>
   <td>-<br></td>
   <td>res_WDG_NETX_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reserved for netX supervision Watchdog Timeout IRQ (not available in this netX version). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>28</td>
   <td>&quot;0&quot;<br></td>
   <td>RDY_TIMEOUT<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Enable for 'dpm_firmware_irq_raw.RDY_TIMEOUT' bit. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>27</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>26</td>
   <td>&quot;0&quot;<br></td>
   <td>SYS_STA<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> System Status Change IRQ Enable. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>25</td>
   <td>-<br></td>
   <td>res_TMR_ro<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> reserved for Timer IRQ (not available in this netX version). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>24&nbsp;-&nbsp;16</td>
   <td>0<br></td>
   <td>-<br></td>
   <td>&nbsp;reserved</td>
  </tr>
  <tr>
   <td>15</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT15<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 15 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>14</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT14<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 14 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>13</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT13<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 13 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>12</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT12<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 12 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>11</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT11<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 11 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>10</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT10<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 10 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>9</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT9<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 9&nbsp;&nbsp;IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>8</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT8<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 8&nbsp;&nbsp;IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>7</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT7<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 7&nbsp;&nbsp;IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>6</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT6<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 6&nbsp;&nbsp;IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>5</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT5<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 5&nbsp;&nbsp;IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>4</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT4<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 4&nbsp;&nbsp;IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>3</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 3&nbsp;&nbsp;IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>2</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 2&nbsp;&nbsp;IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>1</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 1&nbsp;&nbsp;IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td>0</td>
   <td>&quot;0&quot;<br></td>
   <td>HS_EVENT0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> Handshake Event 0&nbsp;&nbsp;IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.). </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_netx_version_bigend16"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_netx_version_bigend16</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM netX Version Register in big endianess 16 data mapping.<br>This registers content is mirrored form asic_ctrl register area and can be set during netX booting phase by netX firmware.<br>This register is not valid if unlocked bit is not set in dpm_status register.<br>Together with dpm_netx_version register, full 32 bit version can be read by any host device, even if DPM interface is not initialized yet.<br>Bytes byte1 and byte3 can be always read here even if DPM is uninitialized (8 bit default from dpm_cfg0x0 after power on) and<br>host device has 8, 16 or 32 bit data width. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp;8 bit DPM </td>
       <td valign=top> &nbsp;16 bit DPM </td>
       <td valign=top> &nbsp;32 bit DPM </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;byte 0 (D7:0) </td>
       <td valign=top> &nbsp;byte read this address +1 </td>
       <td valign=top> &nbsp;adr_dpm_netx_version </td>
       <td valign=top> &nbsp;adr_dpm_netx_version </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;byte 1 (D15:8) </td>
       <td valign=top> &nbsp;byte read this address +0 </td>
       <td valign=top> &nbsp;byte read this address </td>
       <td valign=top> &nbsp;DWord read this address </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;byte 2 (D23:16) </td>
       <td valign=top> &nbsp;byte read this address +3 </td>
       <td valign=top> &nbsp;adr_dpm_netx_version </td>
       <td valign=top> &nbsp;adr_dpm_netx_version </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;byte 3 (D31:24) </td>
       <td valign=top> &nbsp;byte read this address +2 </td>
       <td valign=top> &nbsp;byte read this address +2 </td>
       <td valign=top> &nbsp;byte read this address +0 </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019f4<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001af4<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;24</td>
   <td>netx_version_byte2_swap<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> netX version bits 24 to 16. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>23&nbsp;-&nbsp;16</td>
   <td>netx_version_byte3_swap<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> netX version bits 31 to 24. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>15&nbsp;-&nbsp;8</td>
   <td>netx_version_byte0_swap<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> netX version bits 8 to 0. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>7&nbsp;-&nbsp;0</td>
   <td>netx_version_byte1_swap<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> netX version bits 16 to 8. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
 <a name="dpm0_com_dpm_netx_version"></a>
 <table border cellpadding=2>
  <tr>
   <td align=center colspan=3><font size="+2"><b>dpm_netx_version</b></font></td>
   <td align=left>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> DPM netX Version Register.<br>This register is mirrored form asic_ctrl register area and can be set during netX booting phase by netX firmware.<br>This register is not valid if unlocked bit is not set in dpm_status register.<br>Together with dpm_netx_version register, full 32 bit version can be read by any host device, even if DPM interface is not initialized yet.<br>Bytes byte0 and byte2 can be always read here even if DPM is uninitialized (8 bit default from dpm_cfg0x0 after power on) and<br>host device has 8, 16 or 32 bit data width. </td>
      </tr>
     </table>

     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> &nbsp; </td>
       <td valign=top> &nbsp;8 bit DPM </td>
       <td valign=top> &nbsp;16 bit DPM </td>
       <td valign=top> 32 bit DPM </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;byte 0 (D7:0) </td>
       <td valign=top> &nbsp;byte read this address +0 </td>
       <td valign=top> &nbsp;byte read this address </td>
       <td valign=top> &nbsp;DWord read this address </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;byte 1 (D15:8) </td>
       <td valign=top> &nbsp;byte read this address +1 </td>
       <td valign=top> &nbsp;adr_dpm_netx_version_bigend16 </td>
       <td valign=top> &nbsp;adr_dpm_netx_version_bigend16 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;byte 2 (D23:16) </td>
       <td valign=top> &nbsp;byte read this address +2 </td>
       <td valign=top> &nbsp;byte read this address +2 </td>
       <td valign=top> &nbsp;byte read this address +0 </td>
      </tr>
      <tr>
       <td valign=top> &nbsp;byte 3 (D31:24) </td>
       <td valign=top> &nbsp;byte read this address +3 </td>
       <td valign=top> &nbsp;adr_dpm_netx_version_bigend16 </td>
       <td valign=top> &nbsp;adr_dpm_netx_version_bigend16 </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td align=center colspan=2>R<br></td>
   <td align=left colspan=2>
   <a href="#dpm0_com">Address</a>@dpm0_com&nbsp;:&nbsp;0xff0019fc<br>
   <a href="#dpm1_com">Address</a>@dpm1_com&nbsp;:&nbsp;0xff001afc<br>
   </td>
  </tr>
   <th colspan=2 bgcolor="#ccffcc">Bits</th>
   <th bgcolor="#ccffcc">Name</th>
   <th bgcolor="#ccffcc">Description</th>
  <tr>
   <td colspan=2>31&nbsp;-&nbsp;24</td>
   <td>netx_version_byte3<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> netX version bits 31 to 24. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>23&nbsp;-&nbsp;16</td>
   <td>netx_version_byte2<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> netX version bits 24 to 16. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>15&nbsp;-&nbsp;8</td>
   <td>netx_version_byte1<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> netX version bits 16 to 8. </td>
      </tr>
     </table>
</td>
  </tr>
  <tr>
   <td colspan=2>7&nbsp;-&nbsp;0</td>
   <td>netx_version_byte0<br></td>
   <td>
     <table border="0" cellspacing="1">
      <tr>
       <td valign=top> netX version bits 8 to 0. </td>
      </tr>
     </table>
</td>
  </tr>
 </table><br><br>
</BODY>
</HTML>
