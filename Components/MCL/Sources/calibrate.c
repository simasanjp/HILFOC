/* Copyright (c) 2020 eonas IT-Beratung und -Entwicklung GmbH All rights reserved. */

#include "calibrate.h"

static void Calibration_UpdateLinearPosition(CalibrationStateT *as_State,
                                             uint8_t au8_HallState,
                                             int16_t as16_Theta);
static void Calibration_Module_InitState(CalibrationStateT *as_State,
                                         const CalibrationParameterT *as_Parameter,
                                         CalibrationControlOutputT *as_Output);
static void Calibration_Module_WaitForInitialAlignmentState(CalibrationStateT *as_State,
                                                            const CalibrationParameterT *as_Parameter,
                                                            uint8_t au8_HallState,
                                                            int16_t as16_ElectricalAngle,
                                                            CalibrationControlOutputT *as_Output);
static void Calibration_Module_TurnCWState(CalibrationStateT *as_State,
                                           const CalibrationParameterT *as_Parameter,
                                           uint8_t au8_HallState,
                                           int16_t as16_ElectricalAngle,
                                           CalibrationControlOutputT *as_Output);
static void Calibration_Module_WaitForDirectionChangeAlignment(CalibrationStateT *as_State,
                                                               const CalibrationParameterT *as_Parameter,
                                                               uint8_t au8_HallState,
                                                               int16_t as16_ElectricalAngle,
                                                               CalibrationControlOutputT *as_Output);
static void Calibration_Module_TurnCCWState(CalibrationStateT *as_State, const CalibrationParameterT *as_Parameter,
                                            uint8_t au8_HallState, int16_t as16_ElectricalAngle,
                                            CalibrationControlOutputT *as_Output);

static void Calibration_Module_Evaluate(CalibrationStateT *as_State,  const CalibrationParameterT *as_Parameter,
                                        CalibrationControlOutputT *as_Output);
static void Calibration_Module_ValidateState(CalibrationStateT *as_State,
                                             const CalibrationParameterT *as_Parameter,
                                             uint8_t au8_HallState,
                                             int16_t as16_ElectricalAngle,
                                             CalibrationControlOutputT *as_Output);


void Calibration_Prepare(CalibrationStateT *aps_State) {
  aps_State->e_State                    = CALIBRATION_MODULE_INIT;
  aps_State->s_Error.u1_AlignmentFailed = 0u;
  aps_State->s_Error.u1_WrongHallSequence    = 0u;
}

/**
 * \brief first state of the calibration state machine
 *
 * \warning internal function - not to be called externally
 *
 * Prepares the second state (CALIBRATION_MODULE_WAIT_FOR_INITIAL_ALIGNMENT).
 *
 * \param as_State state to operate on
 * \param as_Parameter parameter given by the user
 * \param as_Output output generated by the function
 */
static void Calibration_Module_InitState(CalibrationStateT *as_State,
                                         const CalibrationParameterT *as_Parameter,
                                         CalibrationControlOutputT *as_Output) {
  as_Output->s16_ElectricalAngle = 0;
  as_Output->s16_SpeedRPM        = 0;
  as_Output->e_Mode              = CALIBRATION_CONTROL_SET_POSITION;

  as_State->u16_ToWait10Msec = as_Parameter->u16_WaitTimeAfterAlignment10Msec;
  as_State->e_State          = CALIBRATION_MODULE_WAIT_FOR_INITIAL_ALIGNMENT;
}

static void Calibration_Module_WaitForInitialAlignmentState(CalibrationStateT *as_State,
                                                            const CalibrationParameterT *as_Parameter,
                                                            uint8_t au8_HallState,
                                                            int16_t as16_ElectricalAngle,
                                                            CalibrationControlOutputT *as_Output) {
  as_State->u8_LastHallState = au8_HallState;
  if (as_State->u16_ToWait10Msec > 0) {
    as_Output->s16_ElectricalAngle = 0;
    as_Output->s16_SpeedRPM        = 0;
    as_Output->e_Mode              = CALIBRATION_CONTROL_SET_POSITION;

    as_State->u16_ToWait10Msec--;
  } else {

    as_State->u16_ToWait10Msec = as_Parameter->u16_WaitTimeBetweenEachSample10Msec;
    as_State->u8_LastHallState = au8_HallState;
    as_State->u16_LastTheta    = as16_ElectricalAngle;
    as_State->u16_ToWait10Msec = as_Parameter->u16_WaitTimeBetweenEachSample10Msec;

    as_Output->s16_ElectricalAngle = 0;
    as_Output->s16_SpeedRPM        = as_Parameter->s16_SamplingSpeedRPM;
    as_Output->e_Mode              = CALIBRATION_CONTROL_SET_SPEED;

    as_State->e_State = CALIBRATION_MODULE_TURN_CW;
  }
}

static void Calibration_Module_TurnCWState(CalibrationStateT *as_State,
                                           const CalibrationParameterT *as_Parameter,
                                           uint8_t au8_HallState,
                                           int16_t as16_ElectricalAngle,
                                           CalibrationControlOutputT *as_Output) {

  Calibration_UpdateLinearPosition(as_State, au8_HallState, as16_ElectricalAngle);
  if (as_State->u16_ToWait10Msec > 0) {
    as_Output->s16_ElectricalAngle = 0;
    as_Output->s16_SpeedRPM        = as_Parameter->s16_SamplingSpeedRPM;
    as_Output->e_Mode              = CALIBRATION_CONTROL_SET_SPEED;

    as_State->u16_ToWait10Msec--;
  }
  else
  {
    if (as_State->u8_nthTurn == as_Parameter->s16_NumberOfTurns) {

      as_State->u16_ToWait10Msec = as_Parameter->u16_WaitTimeAfterAlignment10Msec;

      as_Output->s16_ElectricalAngle = 0;
      as_Output->s16_SpeedRPM        = 0;
      as_Output->e_Mode              = CALIBRATION_CONTROL_SET_SPEED;

      as_State->e_State = CALIBRATION_MODULE_WAIT_FOR_DIRECTION_CHANGE_ALIGNMENT;

    } else {
      as_State->u16_ToWait10Msec     = as_Parameter->u16_WaitTimeBetweenEachSample10Msec;
      as_Output->s16_ElectricalAngle = 0;
      as_Output->s16_SpeedRPM        = as_Parameter->s16_SamplingSpeedRPM;
      as_Output->e_Mode              = CALIBRATION_CONTROL_SET_SPEED;
    }
  }
}

static void Calibration_Module_WaitForDirectionChangeAlignment(CalibrationStateT *as_State,
                                                               const CalibrationParameterT *as_Parameter,
                                                               uint8_t au8_HallState,
                                                               int16_t as16_ElectricalAngle,
                                                               CalibrationControlOutputT *as_Output) {
  //Calibration_UpdateLinearPosition(as_State, au8_HallState, as16_ElectricalAngle);
  as_State->u8_LastHallState = au8_HallState;
  if (as_State->u16_ToWait10Msec > 0) {
    as_Output->s16_ElectricalAngle = 0;
    as_Output->s16_SpeedRPM        = 0;
    as_Output->e_Mode              = CALIBRATION_CONTROL_SET_POSITION;

    as_State->u16_ToWait10Msec--;
  } else {
    as_State->s8_Index         = 5;
    as_State->u16_ToWait10Msec = as_Parameter->u16_WaitTimeBetweenEachSample10Msec;
    as_State->u8_nthTurn = 0;


    as_Output->s16_ElectricalAngle = 0;
    as_Output->s16_SpeedRPM        = -as_Parameter->s16_SamplingSpeedRPM;
    as_Output->e_Mode              = CALIBRATION_CONTROL_SET_SPEED;


    as_State->e_State = CALIBRATION_MODULE_TURN_CCW;
  }

}

static void Calibration_Module_TurnCCWState(CalibrationStateT *as_State, const CalibrationParameterT *as_Parameter,
                                            uint8_t au8_HallState, int16_t as16_ElectricalAngle,
                                            CalibrationControlOutputT *as_Output) {

  Calibration_UpdateLinearPosition(as_State, au8_HallState, as16_ElectricalAngle);
  if (as_State->u16_ToWait10Msec > 0) {
    as_Output->s16_ElectricalAngle = 0;
    as_Output->s16_SpeedRPM        = -as_Parameter->s16_SamplingSpeedRPM;
    as_Output->e_Mode              = CALIBRATION_CONTROL_SET_SPEED;

    as_State->u16_ToWait10Msec--;
  } else {

    if (as_State->u8_nthTurn == as_Parameter->s16_NumberOfTurns) {

      as_State->e_State = CALIBRATION_MODULE_EVALUATE;
      as_Output->e_Mode = CALIBRATION_CONTROL_OFF;
    } else {
      as_State->u16_ToWait10Msec     = as_Parameter->u16_WaitTimeBetweenEachSample10Msec;
      as_Output->s16_ElectricalAngle = 0;
      as_Output->s16_SpeedRPM        = -as_Parameter->s16_SamplingSpeedRPM;
      as_Output->e_Mode              = CALIBRATION_CONTROL_SET_SPEED;
    }
  }
}
static void Calibration_Module_Evaluate(CalibrationStateT *as_State, const CalibrationParameterT *as_Parameter,
                                        CalibrationControlOutputT *as_Output){
  uint8_t lu8_i;
  uint8_t lu8_Mismatch = 0;
  /* Check if CW and CCW sectors matches */
  for (lu8_i = 0; lu8_i < 6; lu8_i++){

    if (Math_QuasyEqual(as_State->s_Sector.u16_SamplesCW[lu8_i], as_State->s_Sector.u16_SamplesCCW[lu8_i], as_Parameter->u16_MaximumDeviationAngle)){
    /* Boundary matches, record calibrated value */
      as_State->s_Sector.u16_Calibrated[lu8_i] = (uint16_t)(((uint32_t)as_State->s_Sector.u16_SamplesCW[lu8_i]
                                                           + (uint32_t)as_State->s_Sector.u16_SamplesCCW[lu8_i])/2U);
    }
    else
    {
      lu8_Mismatch = 1;
    }
  }

  if(lu8_Mismatch){
    as_State->e_State = CALIBRATION_MODULE_FAILED;
    as_State->s_Error.u1_WrongHallSequence = 1;
  }else{
    as_State->e_State = CALIBRATION_MODULE_DONE;
  }
}

static void Calibration_Module_ValidateState(CalibrationStateT *as_State,
                                             const CalibrationParameterT *as_Parameter,
                                             uint8_t au8_HallState,
                                             int16_t as16_ElectricalAngle,
                                             CalibrationControlOutputT *as_Output) {
//TODO:
}

void Calibration_Task10ms(CalibrationStateT *aps_State,
                          const CalibrationParameterT *aps_Parameter,
                          uint8_t au8_HallState,
                          int16_t as16_ElectricalAngle,
                          CalibrationControlOutputT *aps_Output) {
  aps_Output->s_RequestedVoltage.f_d = aps_Parameter->f_RequestedVoltage;
  aps_Output->s_RequestedVoltage.f_q = 0.0f;

  switch (aps_State->e_State) {
    case CALIBRATION_MODULE_INIT:
      Calibration_Module_InitState(aps_State, aps_Parameter, aps_Output);
      break;
    case CALIBRATION_MODULE_WAIT_FOR_INITIAL_ALIGNMENT:
      Calibration_Module_WaitForInitialAlignmentState(aps_State, aps_Parameter, au8_HallState,
                                                      as16_ElectricalAngle, aps_Output);
      break;
    case CALIBRATION_MODULE_TURN_CW:
      Calibration_Module_TurnCWState(aps_State, aps_Parameter, au8_HallState, as16_ElectricalAngle,
                                     aps_Output);
      break;
    case CALIBRATION_MODULE_WAIT_FOR_DIRECTION_CHANGE_ALIGNMENT:
      Calibration_Module_WaitForDirectionChangeAlignment(aps_State, aps_Parameter, au8_HallState,
                                                         as16_ElectricalAngle,
                                                         aps_Output);
      break;
    case CALIBRATION_MODULE_TURN_CCW:
      Calibration_Module_TurnCCWState(aps_State, aps_Parameter, au8_HallState, as16_ElectricalAngle,
                                      aps_Output);
      break;
    case CALIBRATION_MODULE_EVALUATE:
      Calibration_Module_Evaluate(aps_State, aps_Parameter,
                                  aps_Output);
      break;
    case CALIBRATION_MODULE_VALIDATE:
      Calibration_Module_ValidateState(aps_State, aps_Parameter, au8_HallState, as16_ElectricalAngle,
                                       aps_Output);
      break;
    default:
    case CALIBRATION_MODULE_DONE:
    case CALIBRATION_MODULE_FAILED:
      aps_Output->s_RequestedVoltage.f_d = 0.0f;
      aps_Output->s_RequestedVoltage.f_q = 0.0f;
      aps_Output->e_Mode = CALIBRATION_CONTROL_OFF;
      break;
  }
}

static void Calibration_UpdateLinearPosition(CalibrationStateT *as_State,
                                             uint8_t au8_HallState,
                                             int16_t as16_Theta) {

  if (au8_HallState != as_State->u8_LastHallState){

    if (as_State->e_State == CALIBRATION_MODULE_TURN_CW){
      as_State->u8_HallStates[as_State->s8_Index] = as_State->u8_LastHallState;
      as_State->s_Sector.u16_SamplesCW[as_State->s8_Index] = as16_Theta;
      as_State->s8_Index++;
      if (as_State->s8_Index >= 6){
        as_State->s8_Index = 0;
        as_State->u8_nthTurn++;
      }
    }
    else if(as_State->e_State == CALIBRATION_MODULE_TURN_CCW){
      as_State->s_Sector.u16_SamplesCCW[as_State->s8_Index] = as16_Theta;
      as_State->s8_Index--;
      if (as_State->s8_Index < 0){
        as_State->s8_Index = 5;
        as_State->u8_nthTurn++;
      }
    }
  }
  as_State->u8_LastHallState = au8_HallState;
  as_State->u16_LastTheta = as16_Theta;
}

CalibrationResultT Calibration_GetStatus(const CalibrationStateT *aps_State) {
  CalibrationResultT le_Ret;

  if (aps_State->e_State == CALIBRATION_MODULE_DONE) {
    le_Ret = CALIBRATION_RESULT_OK;
  } else if (aps_State->e_State == CALIBRATION_MODULE_FAILED) {
    le_Ret = CALIBRATION_RESULT_FAILED;
  } else {
    le_Ret = CALIBRATION_RESULT_BUSY;
  }
  return le_Ret;
}

void Calibration_GetErrors(const CalibrationStateT *aps_State, CalibrationErrorT *aps_Errors) {
  aps_Errors->u1_AlignmentFailed = aps_State->s_Error.u1_AlignmentFailed;
  aps_Errors->u1_WrongHallSequence    = aps_State->s_Error.u1_WrongHallSequence;
}




